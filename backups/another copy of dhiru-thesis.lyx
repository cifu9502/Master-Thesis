#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass ubcthesis
\begin_preamble

\usepackage{afterpage}

\usepackage{float}

%\usepackage{alltt}

\usepackage{longtable}

\usepackage{graphicx}

\usepackage{lscape}

%\usepackage[numbers,sort&compress]{natbib}

\usepackage{psfrag}

\usepackage{listings}
\usepackage{minted}
\usepackage{placeins}

%\usepackage[hypertex,final=true,unicode=true, pdfusetitle,bookmarks=true,bookmarksnumbered=false,bookmarksopen=true,breaklinks=true,pdfborder={0 0 1},backref=true,colorlinks=true,citecolor=black, filecolor=black, linkcolor=black, urlcolor=black]{hyperref}
\usepackage{hyperref}
\hypersetup{
hypertex=true,
unicode=true, pdfusetitle,
bookmarks=true,
bookmarksnumbered=false,
bookmarksopen=true,
breaklinks=true,
pdfborder={0 0 1},
backref=true,
colorlinks=true,
citecolor=black,
filecolor=black,
linkcolor=black,
urlcolor=black
}

% These commands are optional.  The defaults are shown.  You only
% need to include them if you need a different value
\institution{The University Of British Columbia}

% If you are at the Okanagan campus, then you should specify these
% instead.
%\faculty{The College of Graduate Studies}
%\institutionaddress{Okanagan}
\faculty{The Faculty of Graduate Studies}
\institutionaddress{Vancouver}

% You can issue as many of these as you have...
\previousdegree{B.E., University of Pune, 2006}

% You can override the option setting here.
% \degreetitle{Jack of All Trades}

% These commands are required.
\title{Advances in password cracking and reverse engineering}
\author{Dhirendra Singh Kholia}
\copyrightyear{2013}
\submitdate{\today}

\program{Computer Science}

% These commands are presently not required for UBC theses as the
% advisor's name and title are not presently required anywhere.
%\advisor{Ariel R.~Zhitnitsky}
%\advisortitle{Professor of Physics}

% One might want to override the format of the section and chapter
% numbers.  This shows you how to do it.  Note that the current
% format is acceptable for submission to the FoGS: If you wish to modify
% these, you should check with the FoGS explicity. prior to making
% the modifications.
\renewcommand\thepart         {\Roman{part}}
\renewcommand\thechapter      {\arabic{chapter}}
\renewcommand\thesection      {\thechapter.\arabic{section}}
\renewcommand\thesubsection   {\thesection.\arabic{subsection}}
\renewcommand\thesubsubsection{\thesubsection.\arabic{subsubsection}}
\renewcommand\theparagraph    {\thesubsubsection.\arabic{paragraph}}
\renewcommand\thesubparagraph {\theparagraph.\arabic{subparagraph}}

% Following now set in LyX
%\setcounter{tocdepth}{2}
%\setcounter{secnumdepth}{2}

% Here is an example of a "Program" environment defined with the
% "float" package.  The list of programs will be stored in the file
% ubcsample.lop and the numbering will start with the chapter
% number.  The style will be "ruled".
\floatstyle{ruled}
\newfloat{Program}{htbp}{lop}[chapter]
\end_preamble
\options msc,oneside
\use_default_options false
\begin_modules
theorems-ams
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman times
\font_sans helvet
\font_typewriter cmtt
\font_default_family rmdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command bibtex
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine natbib_authoryear
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 2
\tocdepth 1
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frontmatter
\end_layout

\begin_layout Plain Layout


\backslash
maketitle
\end_layout

\end_inset


\end_layout

\begin_layout Abstract
This paper presents advances in the areas of password cracking and reverse
 engineering.
 In particular, it describes the design and implementation of various plug-ins
 for John the Ripper 
\begin_inset CommandInset citation
LatexCommand citep
key "Peslyak:1996"

\end_inset

, Ettercap 
\begin_inset CommandInset citation
LatexCommand citep
key "ALoR:2001"

\end_inset

, Nmap 
\begin_inset CommandInset citation
LatexCommand citet
key "Fyodor:1997"

\end_inset

 and Metasploit Framework 
\begin_inset CommandInset citation
LatexCommand citep
key "Moore:2003"

\end_inset

 for mounting attacks against various password protected file formats, password
 managers, authentication protocols and hashed passwords.
 
\end_layout

\begin_layout Abstract
Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:backup-solutions"

\end_inset

 presents the security analysis of various cloud backup solutions (Dropbox,
 inSync Druva).
 Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:file-formats"

\end_inset

 presents security analysis of various file formats (called 
\begin_inset Quotes eld
\end_inset

non-hashes
\begin_inset Quotes erd
\end_inset

) and password managers.
 Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:auth-protocols"

\end_inset

 presents security analysis of various authentication protocols.
 Security analysis of various password hashing algorithms is covered in
 Chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:hashes-JtR"

\end_inset

.
 
\end_layout

\begin_layout Abstract
One of the motivation behind this work is to build open-source security
 tools which can compete with offerings from commercial companies like Elcomsoft
 and Passware, who are well known in the field of password recovery.
 Our work describes various JtR plug-ins offering new functionality which
 is not available even in existing commercial password recovery softwares.
 Some of our plug-ins are even faster and more scalable than the ones available
 commercially.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\begin_inset FloatList figure

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
listof{Program}{List of Programs}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Acknowledgements
\end_layout

\begin_layout Standard
This is the place to thank professional colleagues and people who have given
 you the most help during the course of your graduate work.
 
\end_layout

\begin_layout Standard
I would like to thanks Solar Designer for mentoring my GSoC 2011 (Google
 Summer of Code) work, Robert for collaborating on Mac OS X Keychain work,
 Lukas for GPU implementation of Password Safe format, Nigel for collaborating
 on RACF work, magnum for maintaing JtR-jumbo, Milen for collaborating on
 FileVault work.
\end_layout

\begin_layout Standard
XXX use more words than code
\end_layout

\begin_layout Standard
XXX improve graphs, use gnuplot
\end_layout

\begin_layout Chapter
Dedication
\end_layout

\begin_layout Standard
This thesis is dedicated to the entire john-users and john-dev community.
 Special thanks goes to Solar Designer, magnum and Jim Foug.
\end_layout

\begin_layout Chapter
Statement of Co-Authorship
\end_layout

\begin_layout Standard
While this thesis is authored solely, I was assisted in my research by the
 following people.
 
\end_layout

\begin_layout Itemize
Solar Designer (overall mentorship)
\end_layout

\begin_layout Itemize
RACF hashing format (Nigel Pentland (author of CRACF) and Phil Young).
\end_layout

\begin_layout Itemize
Apple DMG file format (Milen)
\end_layout

\begin_layout Itemize
Apple Keychain format (...)
\end_layout

\begin_layout Itemize
manuscript preparation 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout


\backslash
mainmatter
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% Parts are the largest structural units, but are optional.
\end_layout

\begin_layout Plain Layout

%
\backslash
part{Thesis}
\end_layout

\begin_layout Plain Layout

% Chapters are the next main unit.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Analysis of security of various file formats.
\begin_inset CommandInset label
LatexCommand label
name "chap:file-formats"

\end_inset


\end_layout

\begin_layout Standard
This section presents analysis of various file formats and programs which
 allow encryption of user data from a cracking perspective.
 A note about benchmarking, AMD FX-8120 is not a true 8-core CPU and use
 dynamic frequency scaling, hence the practical speedups obtained by using
 all 8 cores will be less than 8x.
 The maximum speedup factor of AMD FX-8120 is (3.1 GHz / 4 GHz) * 8 = 6x
 when using all 8 cores.
 Almost all the JtR plug-ins described in this paper are multi-core (by
 using OpenMP) as well as multi-node (by using MPI).
 Some of the plug-ins are also implemented in OpenCL resulting in speed-ups
 of over 150x.
\end_layout

\begin_layout Section
Password Safe 3.x 
\begin_inset Note Note
status open

\begin_layout Plain Layout
DONE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Password Safe 
\begin_inset CommandInset citation
LatexCommand citep
key "Schneier:2002"

\end_inset

 is a free and open source software program for storing passwords originally
 authored by Bruce Schneier.
 From a developer point of view, this format has been easiest to write cracking
 code for since the database format is well documented in formatV3.txt file
 
\begin_inset CommandInset citation
LatexCommand citep
key "Shapiro:2003"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand citep
key "Hinegardner:2007"

\end_inset

.
 The same database format is used by Password Gorilla 
\begin_inset CommandInset citation
LatexCommand citep
key "Pilhofer:2006"

\end_inset

 as well as Pasaffe password manager 
\begin_inset CommandInset citation
LatexCommand citep
key "Deslauriers:2011"

\end_inset

, so the analysis here applies to them too.
 See 
\begin_inset CommandInset citation
LatexCommand citep
key "Hinegardner:2007"

\end_inset

 for more details on the database format and encryption / decryption process.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:pwsafe"

\end_inset

 describes the fields present in Password Safe database.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%optional [t, b or h];
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="middle" width="2cm">
<column alignment="left" valignment="middle" width="1.5cm">
<column alignment="left" valignment="middle" width="8cm">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TAG
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The 4 ASCII Characters ‘PWS3’
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SALT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
256 random bit value generated at file creation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ITER
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bit LE value
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
number of rounds in the key stretch algorithm
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
H(P’) aka HASH
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SHA-256 of the user’s 
\begin_inset Quotes eld
\end_inset

processed
\begin_inset Quotes erd
\end_inset

 passphrase
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted 128 random value using P’ with Twofish algorithm
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted 128 random value using P’ with Twofish algorithm
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted 128 random value using P’ with Twofish algorithm
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted 128 random value using P’ with Twofish algorithm
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Init vector
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
128 bit random Initialization Vector for the content’s encryption
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Header
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
General information for the database 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Records
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The records in the database
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EOF 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unencrypted string “PWS3-EOFPWS3-EOF” 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HMAC
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
256 bit SHA-256 hash of the plaintext contents, starting with the version
 number in the header and ending with the last field of the last record
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:pwsafe"

\end_inset

 Password Safe 3 database format (header fields, in order)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
From a cracking perspective, only SALT, ITER and H(P') fields are needed.
 The Password Safe 3 format uses "variable key stretching" to protect a
 database against brute-force attacks.
 The higher the value of "iterations" (ITER) parameter is, the longer it
 to test a candidate password.
 The Password Safe 3 format avoids a potential weakness discovered with
 the old Password Safe 2 ("V2") file format which allowed brute force attacks
 1000 times faster than intended.
 The Password Safe 3 format avoids this issue by depending on the result
 of the key stretching operation and using it as an input for decryption
 of data.
 The key stretching algorithm used in Password Safe is described in Program
 is 
\begin_inset CommandInset ref
LatexCommand ref
reference "prog:psc"

\end_inset

.
 For full implementation details see 
\shape italic
src/pwsafe2john.c
\shape default
 and 
\shape italic
src/pwsafe_fmt_plug.c
\shape default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:psc}Password Safe Cracker
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.4cm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Preview

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SHA256_CTX ctx;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SHA256_Init(&ctx);
\end_layout

\begin_layout Plain Layout

SHA256_Update(&ctx, password, strlen(password);
\end_layout

\begin_layout Plain Layout

SHA256_Update(&ctx, SALT, 32);
\end_layout

\begin_layout Plain Layout

SHA256_Final(output, &ctx);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for(int i = 0; i <= ITER; i++)  {
\end_layout

\begin_layout Plain Layout

	SHA256_Init(&ctx);
\end_layout

\begin_layout Plain Layout

	SHA256_Update(&ctx, output, 32);
\end_layout

\begin_layout Plain Layout

	SHA256_Final(output, &ctx);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(output == HASH) {
\end_layout

\begin_layout Plain Layout

	/* password cracked */
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our CPU version of the cracking software achieves around 896 c/s on a single
 core and 7097 c/s on 2 x Xeon E5420 (8 cores total).
 The GPU version (authored by Lukas Odzioba based on our CPU implementation)
 achieves a speedup of around 89x over single core CPU result.
 Currently, the GPU implementation transfers candidate passwords from CPU
 to GPU which is sub-optimal.
 Future version of JtR will remove this limitation and higher cracking speeds
 can be expected.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/Password Safe Benchmarks.png
	scale 75

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Password Safe Cracking Benchmarks
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.4cm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:fib}Password Safe Benchmarks
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
ttfamily,breaklines=true,columns=flexible,xleftmargin=1pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C]{resources/pwsafe_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
FloatBarrier
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Password Safe doesn't support the use of "Key Files" (described in 
\begin_inset CommandInset citation
LatexCommand citep
key "Reichl:2003"

\end_inset

) .
 However, for added security, YubiKey hardware 
\begin_inset CommandInset citation
LatexCommand citep
key "Ehrensvrd:2007"

\end_inset

 which provides 2-Factor Authentication can be used with Password Safe program.
 So far, no vulnerabilities have been been published for the YubiKey device.
 Also, it is trivial to increase resistance against brute-force attacks
 by simply increasing the value of ITER field
\end_layout

\begin_layout Section
Apple Mac OS X Keychain 
\begin_inset Note Note
status open

\begin_layout Plain Layout
DONE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Apple's keychain is a password management system in Mac OS.
 Keychain software is an integral part of Mac OS since Mac OS 8.6.
 In Mac OS X, keychain files are stored in ~/Library/Keychains/, /Library/Keycha
ins/, and /Network/Library/Keychains.
 The default keychain file is the login keychain (which all users have),
 typically unlocked on login by the user's login password (blurb borrowed
 from 
\begin_inset CommandInset citation
LatexCommand citet
key "Misc:1999"

\end_inset

).
\end_layout

\begin_layout Standard
Keychain is an open-source software but compiling modern versions of it
 on modern Mac OS systems is next to impossible (The whole OpenDarwin project
 was abandoned in 2006 and the new PureDarwin project has been unable to
 build security subsystem).
 Some of the bits required to build Keychain haven't been released as open-sourc
e further complicating the compilation process.
 In addition, Apple's own documentation regarding Keychain's file format
 
\begin_inset CommandInset citation
LatexCommand citet
key "Apple:2004"

\end_inset

 is bogus.
 All these points lead us to doubt the usefulness of Apple's open-source
 strategy.
\end_layout

\begin_layout Standard
Our JtR plug-in and security analysis of Mac OS X Keychain is an extension
 of the original research done by Matt Johnston (author of extractkeychain
 program 
\begin_inset CommandInset citation
LatexCommand citep
key "Johnston:2004"

\end_inset

).
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:keychain"

\end_inset

 describes the file format uses by Apple's Keychain software.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%optional [t, b or h];
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="5.5cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Offset
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Length
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Purpose
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Magic Number
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identify Keychain files
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Version
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identify Keychain version 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
crypto-offset
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
offset of the encryption and signing key (length 48)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
total length
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
total length of the keychain
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
signature
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sequence
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
idle timeout
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Idle time after which the Keychain is locked automatically
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
lock on sleep flag
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
44
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SALT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Salt for PKBDF2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IV 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Initialization vector for 3DES-EDE
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
72
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Blob Signature
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Checksum of the blob
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
crypto-offset
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
48 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ciphertext Data
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
encryption and signing key (length 48)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:keychain"

\end_inset

 Apple Keychain file format (DbBlob)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Mac OS X Keychain Services API provides functions to perform most of the
 Keychain operations needed by applications.
 By using the SecKeychainUnlock function exposed by the mentioned API, it
 is trivial to create a small bruteforce attack program.
 An example of such a cracker is shown in Program 
\begin_inset CommandInset ref
LatexCommand ref
reference "prog:keychain"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:keychain}Keychain Trivial Cracker
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

#include <Security/SecKeychain.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  OSStatus err;
\end_layout

\begin_layout Plain Layout

  char passphrase[128];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  /* attack default keychain */
\end_layout

\begin_layout Plain Layout

  SecKeychainRef keychain = NULL;
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  /* argv[1] contains target keychain's name */
\end_layout

\begin_layout Plain Layout

  while(fgets(passphrase, 128, stdin) != NULL) {
\end_layout

\begin_layout Plain Layout

    err = SecKeychainUnlock(keychain,
\end_layout

\begin_layout Plain Layout

      strlen(password), password, TRUE);
\end_layout

\begin_layout Plain Layout

    if (!err) {
\end_layout

\begin_layout Plain Layout

      printf ("Password Found : %s
\backslash
n", password);
\end_layout

\begin_layout Plain Layout

      exit(0);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, such programs are capable of running only on Mac OS systems.
 In addition, the cracking speed of such programs is typically limited to
 < 500 passwords per second on modern processors and it is not possible
 to take advantage of multiple cores due to single-threaded nature of securityd.
 To overcome these limitations, we have build a custom multi-core cross-platform
 cracking software for Mac OS X Keychain.
 
\end_layout

\begin_layout Standard
The interesting parts of the Keychain are called "blobs" (see 
\begin_inset CommandInset citation
LatexCommand citep
key "Johnston:2004"

\end_inset

) and there are two types of blobs: database blobs and key blobs.
 There’s only one DbBlob (at the end of the file), and that contains the
 file encryption key (amongst other things), encrypted with the master key.
 The master key is derived purely from the user’s password, and a salt,
 also found in the DbBlob.
 PKCS #5 v2.0 PBKDF2 
\begin_inset CommandInset citation
LatexCommand citep
key "kaliski2000pkcs:2000"

\end_inset

 is used for deriving the master key.
 The Mac OS X keychain uses the HMAC-SHA-1 function with 1000 iterations,
 a salt length of 20 bytes and intended length of 24 bytes.
 In other words, Master Key = PBKDF2-HMAC-SHA(PASSWORD, SALT, 1000, 24).
 This master key is used to decrypt the encrypted file encryption key.
 The Mac OS X keychain uses CMS padding 
\begin_inset CommandInset citation
LatexCommand citep
key "housley1999cryptographic:1999"

\end_inset

 for wrapping the file encryption key.
 The original un-encrypted file encryption key material has length equal
 to 44 bytes which is padded to 48 bytes before 3DES encryption.
 We exploit this padding knowledge to figure out if we have successfully
 decrypted the encrypted file encryption key.
 We do not know of any other existing research work which uses this technique.
 The key steps involved are shown in Program 
\begin_inset CommandInset ref
LatexCommand ref
reference "prog:keychainpro"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:keychainpro}Keychain Cracker
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

/* CIPHERTEXT is encrypted file encryption key */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* generate encryption key */
\end_layout

\begin_layout Plain Layout

unsigned int master[8];
\end_layout

\begin_layout Plain Layout

pbkdf2(PASSWORD,  strlen(PASSWORD), SALT, 
\backslash

\end_layout

\begin_layout Plain Layout

  SALTLEN, 1000, master);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DES_cblock key1, key2, key3;
\end_layout

\begin_layout Plain Layout

DES_cblock ivec;
\end_layout

\begin_layout Plain Layout

DES_key_schedule ks1, ks2, ks3;
\end_layout

\begin_layout Plain Layout

memcpy(key1, key, 8);
\end_layout

\begin_layout Plain Layout

memcpy(key2, key + 8, 8);
\end_layout

\begin_layout Plain Layout

memcpy(key3, key + 16, 8);
\end_layout

\begin_layout Plain Layout

DES_set_key((C_Block *) key1, &ks1);
\end_layout

\begin_layout Plain Layout

DES_set_key((C_Block *) key2, &ks2);
\end_layout

\begin_layout Plain Layout

DES_set_key((C_Block *) key3, &ks3);
\end_layout

\begin_layout Plain Layout

memcpy(ivec, IV, 8);
\end_layout

\begin_layout Plain Layout

DES_ede3_cbc_encrypt(CIPHERTEXT, out, 48, 
\backslash

\end_layout

\begin_layout Plain Layout

   &ks1, &ks2, &ks3, &ivec,  DES_DECRYPT);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// now check padding
\end_layout

\begin_layout Plain Layout

pad = out[47];
\end_layout

\begin_layout Plain Layout

if(pad > 8)
\end_layout

\begin_layout Plain Layout

   // "Bad padding byte.
 Wrong Password.
\end_layout

\begin_layout Plain Layout

   return -1;
\end_layout

\begin_layout Plain Layout

if(pad != 4) 
\end_layout

\begin_layout Plain Layout

   // "Bad padding value.
 Wrong Password.
\end_layout

\begin_layout Plain Layout

   return -1;
\end_layout

\begin_layout Plain Layout

n = CTLEN - pad;
\end_layout

\begin_layout Plain Layout

for(i = n; i < CTLEN; i++)
\end_layout

\begin_layout Plain Layout

   if(out[i] != pad)
\end_layout

\begin_layout Plain Layout

      // "Bad padding.
 Wrong Password.
\end_layout

\begin_layout Plain Layout

   return -1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// padding check passed, password found!
\end_layout

\begin_layout Plain Layout

printf("Password Found");
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For full implementation details see 
\shape italic
src/keychain2john.c
\shape default
, 
\shape italic
src/keychain_fmt_plug.c
\shape default
 and 
\shape italic
src/opencl_keychain_fmt.c
\shape default
 files.
 The algorithms used in our JtR plug-in have been verified by Robert Vežnaver
 in his master's thesis 
\begin_inset CommandInset citation
LatexCommand citep
key "VeÅŸnaver:2012"

\end_inset

.
\end_layout

\begin_layout Standard
Our initial GPU implementation which does PBKDF2 operations on GPU and 3DES
 operations on multiple-cores is roughly 332X faster than the single-core
 AMD X3 720 CPU results.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/Keychain Benchmarks.png
	scale 75

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Keychain Cracking Benchmarks
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.4cm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:keychainout}OSX Keychain Benchmarks
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
ttfamily,breaklines=true,columns=flexible,xleftmargin=1pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C]{resources/keychain_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
FloatBarrier
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In our opinion, the default number of iterations (1, 000) should be increased
 for added security against brute-force attacks.
 However, the current file format used by Keychain does not provide a way
 to do so without breaking compatibility with existing Mac OS systems.
 Our cracker is the fastest as well as the only GPU based cracker for Mac
 OS Keychain files.
\end_layout

\begin_layout Section
1Password Keychains (Cloud and Agile Keychains) 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Update
\end_layout

\end_inset


\end_layout

\begin_layout Standard
1Password is a popular password manager available for Windows, iPad, iPhone,
 Android and Mac platforms.
 1Password supports two file formats (called Agile Keychain and Cloud Keychain)
 which is different from Apple's Keychain file format.
 The goal of the Agile Keychain file is to build on the successes of the
 Mac OS X keychain while increasing the flexibility and portability of the
 keychain design (
\begin_inset CommandInset citation
LatexCommand citet
key "AgileBits:2008"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand citet
key "AgileBits:2012"

\end_inset

) .
 1Password stores its data in a folder called 
\begin_inset Quotes eld
\end_inset

1Password.agilekeychain
\begin_inset Quotes erd
\end_inset

.
 1Password uses JSON (JavaScript Object Notation) format to store its data
 which has a benefit that its files can be loaded directly into a web browser.
 It is possible to access the data, without installing 1Password software
 , by using a web browser.
 Our JtR plug-in and security analysis of Agile Keychain is an extension
 of the original research done by Antonin Amand (author of agilekeychain,
 see 
\begin_inset CommandInset citation
LatexCommand citep
key "Amand:2009"

\end_inset

)
\end_layout

\begin_layout Standard
The core of the encryption is AES (Advanced Encryption Standard) using 128-bit
 encryption keys and performed in Cipher Block Chaining (CBC) mode along
 with a randomized Initialization Vector.
 Instead of encrypting data with the password directly, a random key of
 1024 bytes is used.
 This key is stored in the encryptionKeys.js file, encrypted using a key
 derived from the users master password by using PBKDF2 function.
 A sample encryptionKeys.js is shown in Program 
\begin_inset CommandInset ref
LatexCommand ref
reference "prog:agilekeychain"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[H]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:agilekeychain}Sample encryptionKeys.js
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{js}
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    "list": [
\end_layout

\begin_layout Plain Layout

        {
\end_layout

\begin_layout Plain Layout

            "data": "U2FsdGVkX19xRuqhzKOV5efr...",
\end_layout

\begin_layout Plain Layout

            "validation": "U2FsdGVkX19dIEp7VK09LOf...",
\end_layout

\begin_layout Plain Layout

            "identifier": "1D169F66FAAC4745A4C708B254944791",
\end_layout

\begin_layout Plain Layout

            "iterations": 1000
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    ]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    SALT = identifier value
\end_layout

\begin_layout Plain Layout

    User_Encryption_Key = PBKDF2-HMAC-SHA(PASSWORD, 
\backslash

\end_layout

\begin_layout Plain Layout

        SALT, iterations, 16)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have written a Python program 
\shape italic
(run/agilekc2john.py
\shape default
) which parses Agile Keychain data and generates a 
\begin_inset Quotes eld
\end_inset

hash
\begin_inset Quotes erd
\end_inset

 which is understood by JtR.
 1Password uses PKCS#7 padding
\begin_inset CommandInset citation
LatexCommand citep
key "kaliski1998pkcs"

\end_inset

 for wrapping the random encryption key.
 We exploit this padding knowledge to figure out if we have successfully
 decrypted the random encryption key.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Agile Keychain Benchmarks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/Agile Keychain Benchmarks.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[H]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:agilekeychaincracker}Agile Keychain Cracker
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

/* CIPHERTEXT is encrypted random key */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define CTLEN 1040
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

unsigned int master[8];
\end_layout

\begin_layout Plain Layout

pbkdf2(PASSWORD, strlen(PASSWORD), SALT, SALTLEN, iters, master);
\end_layout

\begin_layout Plain Layout

AES_KEY akey;
\end_layout

\begin_layout Plain Layout

AES_set_decrypt_key(master, 128, &akey);
\end_layout

\begin_layout Plain Layout

AES_cbc_encrypt(CIPHERTEXT, out, CTLEN, &akey, iv, AES_DECRYPT);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// now check padding
\end_layout

\begin_layout Plain Layout

pad = out[CTLEN - 1];
\end_layout

\begin_layout Plain Layout

if(pad < 1 || pad > 16) /* AES block size is 128 bits = 16 bytes */
\end_layout

\begin_layout Plain Layout

   // "Bad padding byte.
 You probably have a wrong password"
\end_layout

\begin_layout Plain Layout

   return -1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

n = CTLEN - pad;
\end_layout

\begin_layout Plain Layout

key_size = n / 8;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if(key_size != 128 && key_size != 192 && key_size != 256)
\end_layout

\begin_layout Plain Layout

   // "invalid key size"
\end_layout

\begin_layout Plain Layout

   return -1;
\end_layout

\begin_layout Plain Layout

for(i = n; i < CTLEN; i++)
\end_layout

\begin_layout Plain Layout

   if(out[i] != pad)
\end_layout

\begin_layout Plain Layout

      // "Bad padding.
 You probably have a wrong password"
\end_layout

\begin_layout Plain Layout

      return -1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// padding check passed, password found!
\end_layout

\begin_layout Plain Layout

printf("Password Found");
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:fib}Agile Keychain Benchmarks
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
ttfamily,breaklines=true,columns=flexible,xleftmargin=1pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C]{resources/agilekeychain_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
FloatBarrier
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In our opinion, the default number of iterations (1,000) should be increased
 for added security against brute-force attacks.
 It is trivial to do so by increasing the value of 
\begin_inset Quotes eld
\end_inset

iterations
\begin_inset Quotes erd
\end_inset

 parameter in encryptionKey.ks file.
 However doing this on mobile platforms might have an adverse impace on
 responsiveness and usability.
 Our cracker is the only known cracker for Agile Keychain files.
 Agile Keychain design has one flaw that it doesn't encrypt and protect
 the metadata (like URL) for a given password.
 This opens up another attack vector against 1Password software.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:fib}Agile Keychain metadata flaw
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
ttfamily,breaklines=true,columns=flexible,xleftmargin=1pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting{resources/agilekeychain_metadata.txt}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It was interesting to see our cracker being tested and blogged about by
 official 1Password developer Jeffrey Goldberg 
\begin_inset CommandInset citation
LatexCommand citep
key "Goldberg:2012"

\end_inset

.
\end_layout

\begin_layout Section
GNOME Keyring 
\begin_inset Note Note
status open

\begin_layout Plain Layout
DONE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
GNOME Keyring is a collection of components in GNOME that store secrets,
 passwords, keys, certificates and make them available to applications.
 GNOME Keyring is integrated with the user's login, so that their secret
 storage can be unlocked when the user logins into their session.
 GNOME Keyring is a daemon application designed to take care of the user's
 security credentials, such as user names and passwords.
 The sensitive data is encrypted and stored in a keyring file in the user's
 home folder (in ~/.gnome2/keyrings folder) and have 
\begin_inset Quotes eld
\end_inset

keyring
\begin_inset Quotes erd
\end_inset

 extension.
 The default keyring uses the login password for encryption, so users don't
 need to remember yet another password 
\begin_inset CommandInset citation
LatexCommand citep
key "GnomeKeyring"

\end_inset

.
\end_layout

\begin_layout Standard
GNOME Keyring is implemented as a daemon and uses the process name gnome-keyring
-daemon.
 Applications can store and request passwords by using the libgnome-keyring
 library.
 GNOME Keyring is used by various applications like Firefox, Chromium and
 SSH to stores credentials.
\end_layout

\begin_layout Standard
Our program gkcrack 
\begin_inset CommandInset citation
LatexCommand citep
key "kholia:2012"

\end_inset

 is the only program that can crack password protected GNOME Keyrings.
 However, gkcrack program is not a multi-core capable API due to the gnome-keyri
ng-daemon being single threaded.
 Besides, gkcrack requires GNOME Keyring daemon to be running and also keyring
 files must be accessible to the daemon.
 Program 
\begin_inset CommandInset ref
LatexCommand ref
reference "prog:keyring-trivial"

\end_inset

 shows the sketch of gkcrack program.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[H]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:keyring-trivial}Trivial GNOME Keyring cracker
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

#include <gnome-keyring.h>
\end_layout

\begin_layout Plain Layout

#include <stdio.h>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int main(int argc, char **argv)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   char passphrase[128];
\end_layout

\begin_layout Plain Layout

   GnomeKeyringResult r;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /* argv[1] contains target keychain's name */
\end_layout

\begin_layout Plain Layout

    while(fgets(passphrase, N, stdin) != NULL) {
\end_layout

\begin_layout Plain Layout

       r = gnome_keyring_unlock_sync(argv[1], passphrase);
\end_layout

\begin_layout Plain Layout

       if (r == GNOME_KEYRING_RESULT_OK) {
\end_layout

\begin_layout Plain Layout

          printf("Password Found : %s
\backslash
n", passphrase);
\end_layout

\begin_layout Plain Layout

          exit(0);
\end_layout

\begin_layout Plain Layout

       }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:keyring"

\end_inset

 describes the file format used by GNOME Keyring and is based on official
 documentation document 
\begin_inset Quotes eld
\end_inset

file-format.txt
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
key "Larsson:2003"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%optional [t, b or h];
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="16" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="5cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Offset
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Length
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Purpose
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Magic
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
"GnomeKeyring
\backslash
n
\backslash
r
\backslash
0
\backslash
n"
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Version
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identify version 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 byte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
crypto
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
identify crypto algorithm
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 byte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hash
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
identify hash algorithm
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
XX bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
keyring name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
keyring name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20 + XX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ctime
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
24 + XX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mtime
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
modified time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28 + XX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
flags
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 + XX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
lock_timeout
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Idle time after which the Keyring is locked automatically
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36 + XX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hash_iterations 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of iterations, used in KDF
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
40 + XX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
salt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
48 + XX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
num_items
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of items
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
52 + XX
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
YY bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
num_items data
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
52 + XX + YY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
num_encrypted bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
56 + XX + YY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
encryted hash 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(for decrypt ok verify)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:keyring"

\end_inset

 GNOME Keyring file format
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To overcome these limitations of gkcrack, we have implemented an alternate
 parser and cracker (a JtR plug-in) for Keyring databases.
 This parser (see
\shape italic
 src/keyring2john.c
\shape default
 for details) outputs a 
\begin_inset Quotes eld
\end_inset

hash
\begin_inset Quotes erd
\end_inset

 which can be cracked by corresponding JtR plug-in.
 GNOME Keyring uses a custom key derivation function based on SHA256 hash
 function.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:keyring-KDF}GNOME Keyring KDF
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

/* derive KEY and IV from PASSWORD and SALT */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

symkey_generate_simple(PASSWORD, SALT, iterations, key, iv)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

   at_key = key;
\end_layout

\begin_layout Plain Layout

   at_iv = iv;
\end_layout

\begin_layout Plain Layout

   needed_key = 16;
\end_layout

\begin_layout Plain Layout

   needed_iv = 16;
\end_layout

\begin_layout Plain Layout

   n_digest = 32;  /* SHA256 digest size */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   for (pass = 0;; ++pass) {
\end_layout

\begin_layout Plain Layout

      SHA256_Init(&ctx);      
\end_layout

\begin_layout Plain Layout

      /* Hash in the previous buffer on later passes */
\end_layout

\begin_layout Plain Layout

      if (pass > 0)
\end_layout

\begin_layout Plain Layout

         SHA256_Update(&ctx, digest, n_digest);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      if (password) {
\end_layout

\begin_layout Plain Layout

         SHA256_Update(&ctx, password, n_password);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      if (salt && n_salt)
\end_layout

\begin_layout Plain Layout

         SHA256_Update(&ctx, salt, n_salt);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     SHA256_Final(digest, &ctx);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

     for (i = 1; i < iterations; ++i) {
\end_layout

\begin_layout Plain Layout

        SHA256_Init(&ctx);
\end_layout

\begin_layout Plain Layout

        SHA256_Update(&ctx, digest, n_digest);
\end_layout

\begin_layout Plain Layout

        SHA256_Final(digest, &ctx);
\end_layout

\begin_layout Plain Layout

     }
\end_layout

\begin_layout Plain Layout

     /* Copy as much as possible into the destinations */
\end_layout

\begin_layout Plain Layout

     i = 0;
\end_layout

\begin_layout Plain Layout

     while (needed_key && i < n_digest) {
\end_layout

\begin_layout Plain Layout

        *(at_key++) = digest[i];
\end_layout

\begin_layout Plain Layout

        needed_key--;
\end_layout

\begin_layout Plain Layout

        i++;
\end_layout

\begin_layout Plain Layout

     }
\end_layout

\begin_layout Plain Layout

     while (needed_iv && i < n_digest) {
\end_layout

\begin_layout Plain Layout

        if (at_iv)
\end_layout

\begin_layout Plain Layout

            *(at_iv++) = digest[i];
\end_layout

\begin_layout Plain Layout

            needed_iv--;
\end_layout

\begin_layout Plain Layout

            i++;
\end_layout

\begin_layout Plain Layout

     }
\end_layout

\begin_layout Plain Layout

     if (needed_key == 0 && needed_iv == 0)
\end_layout

\begin_layout Plain Layout

        break;
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
By using the above KDF an AES key and IV are derived, which are then used
 for decrypting data.
 AES-128 is used in CBC mode in GNOME Keyring for encrypting and decrypting
 data.
 We have written a custom cracker for GNOME Keyring files and following
 snippet shows the main steps involved,
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:keyringpro}GNOME Keyring cracker
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

decrypt_buffer(buffer, len, salt, iterations, password)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	unsigned char key[32];
\end_layout

\begin_layout Plain Layout

	unsigned char iv[32];
\end_layout

\begin_layout Plain Layout

	AES_KEY akey;
\end_layout

\begin_layout Plain Layout

	symkey_generate_simple(password, strlen(password), 
\backslash

\end_layout

\begin_layout Plain Layout

        salt, 8, iterations, key, iv);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	(AES_set_decrypt_key(key, 128, &akey);
\end_layout

\begin_layout Plain Layout

	AES_cbc_encrypt(buffer, buffer, len, &akey, 
\backslash

\end_layout

\begin_layout Plain Layout

        iv, AES_DECRYPT);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

verify_decrypted_buffer(buffer, len)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	unsigned char digest[16];
\end_layout

\begin_layout Plain Layout

	MD5_CTX ctx;
\end_layout

\begin_layout Plain Layout

	MD5_Init(&ctx);
\end_layout

\begin_layout Plain Layout

	MD5_Update(&ctx, buffer + 16, len - 16);
\end_layout

\begin_layout Plain Layout

	MD5_Final(digest, &ctx);
\end_layout

\begin_layout Plain Layout

	return memcmp(buffer, digest, 16) == 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

decrypt_buffer(input, crypto_size, salt, iterations, password);
\end_layout

\begin_layout Plain Layout

if (verify_decrypted_buffer(input, cur_salt->crypto_size) == 1)
\end_layout

\begin_layout Plain Layout

	/* Password found */
\end_layout

\begin_layout Plain Layout

else
\end_layout

\begin_layout Plain Layout

	/* Password is incorrect */
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
For details see 
\shape italic
src/keyring2john.c
\shape default
, 
\shape italic
src/keyring_fmt_plug.c
\shape default
 and
\shape italic
 doc/README.keyring
\shape default
 files in the JtR source tree.
\end_layout

\begin_layout Standard
We compare the performance of gkcrack and GNOME Keyring JtR plug-in on different
 machines below,
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/Keyring Benchmarks.png
	scale 75

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
GNOME Keyring Cracking Benchmarks
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:fib}GNOME Keyring cracking benchmarks
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
ttfamily,breaklines=true,columns=flexible,xleftmargin=1pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C]{resources/keyring_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
FloatBarrier
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We were also able to attach debugger to a running GNOME Keyring daemon process
 and harvest passwords in clear-text.
 This attacks works (in-spite of symbols being stripped out) by breaking
 and tracing calls to gcry_md_write function which is part of the libgcrypt
 library.
\end_layout

\begin_layout Standard
It is possible to port our CPU based GNOME Keyring cracker to run on GPUs
 by using OpenCL.
 OpenCL port of our GNOME Keyring cracker is under development.
 We predict a performance improvement of > 100X based on our experience
 with Apple Keychain format.
 
\end_layout

\begin_layout Section
KDE KWallet 
\begin_inset Note Note
status open

\begin_layout Plain Layout
DONE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
KDE Wallet Manager is a tool to manage the passwords on a KDE system and
 is described in 
\begin_inset CommandInset citation
LatexCommand citep
key "staikos2003kwallet"

\end_inset

.
 KDE Wallet Manager stores passwords in encrypted files, called "wallets"
 (located in ~/.kde4/share/apps/kwallet folder), which have 
\begin_inset Quotes eld
\end_inset

kwl
\begin_inset Quotes erd
\end_inset

 extension.
 KDE KWallet is implemented as a daemon and uses the process name kwalletd.
 Applications can store and request passwords by using the libsecret library.
 Our program kwalletcrack
\begin_inset CommandInset citation
LatexCommand citep
key "dkholia:2012"

\end_inset

 is the only program that can crack password protected KDE KWallet 
\begin_inset Quotes eld
\end_inset

wallets
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:kwallet"

\end_inset

 describes the file format used by KDE Wallet and is based on the original
 KWallet paper
\begin_inset CommandInset citation
LatexCommand citep
key "Staikos2003"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

%optional [t, b or h];
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Offset
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Length
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Magic String 
\begin_inset Quotes eld
\end_inset

KWALLET
\backslash
n
\backslash
r
\backslash
0
\backslash
r
\backslash
n
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 byte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Format Version - Major (0)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 byte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Format Version - Minor (0)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 byte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cipher Version (0 - CBC Blowfish)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 byte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hash Version (0 - SHA-1)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Whitening block
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
36
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes BE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Length of the data stream
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
?? bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
QDataStream output
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
??
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
?? bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Padding (random data)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
??
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Data hash
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:kwallet"

\end_inset

 KDE KWallet file format
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
KDE KWallet uses a custom key derivation function based on the SHA256 hash
 function.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:keyringpro}KDE Wallet simplified KDF
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

password2hash(password, output)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    SHA_CTX ctx;
\end_layout

\begin_layout Plain Layout

    unsigned char block1[20] = { 0 };
\end_layout

\begin_layout Plain Layout

    int i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    SHA1_Init(&ctx);
\end_layout

\begin_layout Plain Layout

    SHA1_Update(&ctx, password, MIN(strlen(password), 16));
\end_layout

\begin_layout Plain Layout

    for (i = 0; i < 2000; i++) {
\end_layout

\begin_layout Plain Layout

        SHA1_Final(block1, &ctx);
\end_layout

\begin_layout Plain Layout

        SHA1_Init(&ctx);
\end_layout

\begin_layout Plain Layout

        SHA1_Update(&ctx, block1, 20);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    memcpy(hash, block1, 20);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is possible to mount time–memory trade-off attacks 
\begin_inset CommandInset citation
LatexCommand citep
key "oechslin2003making"

\end_inset

 (i.e.
 use Rainbow Tables) against KDE KWallet since it doesn't employ any salting.
 Blowfish CBC 
\begin_inset CommandInset citation
LatexCommand citep
key "schneier1994description"

\end_inset

 with 160-bit key is used for encryption and decryption of data.
\end_layout

\begin_layout Standard
The following program show the main steps involved in decryption of data
 and detection whether the password was correct or not.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:keyringpro}KDE KWallet cracker
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

verify_passphrase(passphrase)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    unsigned char key[20];
\end_layout

\begin_layout Plain Layout

    password2hash(passphrase, key); /* use custom KDF */
\end_layout

\begin_layout Plain Layout

    SHA_CTX ctx;
\end_layout

\begin_layout Plain Layout

    BlowFish _bf;
\end_layout

\begin_layout Plain Layout

    CipherBlockChain bf(&_bf);
\end_layout

\begin_layout Plain Layout

    bf.setKey((void *) key, 20 * 8);
\end_layout

\begin_layout Plain Layout

    bf.decrypt(CIPHERTEXT, CTLEN);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // strip the leading data, one block of random data
\end_layout

\begin_layout Plain Layout

    t = CIPHERTEXT + 8;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    // strip the file size off
\end_layout

\begin_layout Plain Layout

    long fsize = 0;
\end_layout

\begin_layout Plain Layout

    fsize |= (long (*t) << 24) &0xff000000;
\end_layout

\begin_layout Plain Layout

    t++;
\end_layout

\begin_layout Plain Layout

    fsize |= (long (*t) << 16) &0x00ff0000;
\end_layout

\begin_layout Plain Layout

    t++;
\end_layout

\begin_layout Plain Layout

    fsize |= (long (*t) << 8) &0x0000ff00;
\end_layout

\begin_layout Plain Layout

    t++;
\end_layout

\begin_layout Plain Layout

    fsize |= long (*t) & 0x000000ff;
\end_layout

\begin_layout Plain Layout

    t++;
\end_layout

\begin_layout Plain Layout

    if (fsize < 0 || fsize > long (encrypted_size) - 8 - 4) {
\end_layout

\begin_layout Plain Layout

        // file structure error.
 wrong password
\end_layout

\begin_layout Plain Layout

        return -1;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    SHA1_Init(&ctx);
\end_layout

\begin_layout Plain Layout

    SHA1_Update(&ctx, t, fsize);
\end_layout

\begin_layout Plain Layout

    SHA1_Final(testhash, &ctx);
\end_layout

\begin_layout Plain Layout

    // compare hashes
\end_layout

\begin_layout Plain Layout

    sz = encrypted_size;
\end_layout

\begin_layout Plain Layout

    for (i = 0; i < 20; i++) {
\end_layout

\begin_layout Plain Layout

        if (testhash[i] != buffer[sz - 20 + i]) {
\end_layout

\begin_layout Plain Layout

            return -1; /* wrong password */
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    printf("Password Found!");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
FloatBarrier
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The speed achieved by our cracker is 1900+ passwords per second on AMD X3
 720 CPU @ 2.8GHz (using single core).
 It is possible to port our CPU based kwalletcrack program to run on GPUs
 by using OpenCL.
 We predict a performance improvement > 100X based on our experience with
 Apple's Keychain format.
 JtR plug-in and OpenCL port of our KDE KWallet cracker are under development.
 XXX add JtR benchmarks.
\end_layout

\begin_layout Section
KeePass Password Safe (both 1.x and 2.x) 
\begin_inset Note Note
status open

\begin_layout Plain Layout
DONE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
KeePass is a free open source password manager, which helps you to manage
 your passwords in a secure way 
\begin_inset CommandInset citation
LatexCommand citep
key "Reichl:2003"

\end_inset

.
 It is a Windows application with unofficial ports for Linux, Mac OS X and
 Android platforms KeePass stores passwords in an encrypted file (database).
 This database is locked with a master password, a key file and/or the current
 Windows account details.
 To open a database, all key sources (password, key file) are required.
 Together, these key sources form the Composite Master Key 
\begin_inset CommandInset citation
LatexCommand cite
key "KeePass Password Safe Keys"

\end_inset

.
\end_layout

\begin_layout Standard
The 2.x database format is documented only in code and differs from 1.x version
 (which is well documented).
 For more details on database format and encryption / decryption process
 see 
\begin_inset CommandInset citation
LatexCommand citep
key "Hinegardner:2007"

\end_inset

.
 Table XXX shows the header structure of KeePass 1.x databases.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%optional [t, b or h];
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="middle" width="2.5cm">
<column alignment="left" valignment="middle" width="2.5cm">
<column alignment="left" valignment="middle" width="6cm">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FileSignature1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes int LE order
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x9AA2D903, Magic
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FileSignature2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes int LE order 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xB54BFB67, Magic
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Flags
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 byte int LE order
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Determine what algorithms are used 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Version
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 byte int LE order
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Version of the database format 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Final Random Seed / FRS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Initial random number to start on the sha256 of the key 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Init Vector / IV
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Initialization vector used for all algorithms 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Num Group
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 byte int LE order
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted 128 random value using P’ with Twofish algorithm
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Num Entries 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 byte int LE order
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted 128 random value using P’ with Twofish algorithm
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Content Hash / CHASH
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bytes 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SHA256 hash of only the contents (entire file minus starting 124 bytes)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Transformed Random Seed / TRS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bytes 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Random seed used to combine with the master key when calculating the final
 key 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Key Encoding Rounds / ITER 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 byte int LE order
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of rounds to do AES block encryption on the Master Key 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:keepass1"

\end_inset

 KeePass Database Format 1.x
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Contents of the binary file format are in the general format of an unencrypt
ed 124 byte header followed by the encrypted data.
 
\end_layout

\begin_layout Standard
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:keepass2"

\end_inset

 shows the header structure of KeePass 2.x databases.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%optional [t, b or h];
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="middle" width="2.5cm">
<column alignment="left" valignment="middle" width="2.5cm">
<column alignment="left" valignment="middle" width="6cm">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FileSignature1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes int LE order
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x9AA2D903, Magic
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FileSignature2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes int LE order 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xB54BFB67, Magic
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Version
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 byte int LE order
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Versioning Information
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Field ID
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 byte
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identifies type of entry which follows
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Init Vector / IV
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Initialization vector used for all algorithms 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Field ID
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 byte
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identifies type of entry which follows
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Expected Start Bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Used for password validation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Field ID
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 byte
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identifies type of entry which follows
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Transformed Random Seed / TRS
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bytes 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Random seed used to combine with the master key when calculating the final
 key 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Field ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 byte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identifies type of entry which follows
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Key Encoding Rounds / ITERATIONS 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 byte int LE order
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of rounds to do AES block encryption on the Master Key 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Field ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 byte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identifies type of entry which follows
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Final Random Seed / FRS
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Initial random number to start on the sha256 of the key 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:keepass2"

\end_inset

 KeePass 2.x Database Format (some fields are out of order)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To generate the final 256-bit key that is used for the block cipher (for
 data encryption), KeePass first hashes the user's password using SHA-256,
 encrypts the result N times using the Advanced Encryption Standard (AES)
 algorithm (called key transformation rounds from on now), and then hashes
 it again using SHA-256.
 This key-stretching algorithm slows down brute-force attacks significantly
\begin_inset CommandInset citation
LatexCommand cite
key "KeePass Password Safe Protection"

\end_inset

 XXX.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:keyringpro}KeePass custom KDF
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

/* custom KDF based on AES and SHA256 */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

transform_key(char *PASSWORD, final_key)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

     // First, hash the PASSWORD
\end_layout

\begin_layout Plain Layout

    SHA256_CTX ctx;
\end_layout

\begin_layout Plain Layout

    AES_KEY akey;
\end_layout

\begin_layout Plain Layout

    SHA256_Init(&ctx);
\end_layout

\begin_layout Plain Layout

    SHA256_Update(&ctx, PASSWORD, strlen(PASSWORD));
\end_layout

\begin_layout Plain Layout

    SHA256_Final(hash, &ctx);
\end_layout

\begin_layout Plain Layout

    if(version == 2) { /* 2.x database */
\end_layout

\begin_layout Plain Layout

        SHA256_Init(&ctx);
\end_layout

\begin_layout Plain Layout

        SHA256_Update(&ctx, hash, 32);
\end_layout

\begin_layout Plain Layout

        SHA256_Final(hash, &ctx);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    AES_set_encrypt_key(TRS, 256, &akey);    
\end_layout

\begin_layout Plain Layout

    // Next, encrypt the created hash
\end_layout

\begin_layout Plain Layout

    for(i = 0; i < ITERATIONSl; i++) {
\end_layout

\begin_layout Plain Layout

        AES_encrypt(hash, hash, &akey);
\end_layout

\begin_layout Plain Layout

        AES_encrypt(hash+16, hash+16, &akey);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    // Finally, hash it again...
\end_layout

\begin_layout Plain Layout

    SHA256_Init(&ctx);
\end_layout

\begin_layout Plain Layout

    SHA256_Update(&ctx, hash, 32);
\end_layout

\begin_layout Plain Layout

    SHA256_Final(hash, &ctx);
\end_layout

\begin_layout Plain Layout

    // and hash the result together with the Final Random Seed
\end_layout

\begin_layout Plain Layout

    SHA256_Init(&ctx);
\end_layout

\begin_layout Plain Layout

    if(version == 1) {
\end_layout

\begin_layout Plain Layout

        SHA256_Update(&ctx, FRS, 16);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else {
\end_layout

\begin_layout Plain Layout

        SHA256_Update(&ctx, FRS, 32);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    SHA256_Update(&ctx, hash, 32);
\end_layout

\begin_layout Plain Layout

    SHA256_Final(final_key, &ctx);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To validate the password for 1.x version, the full contents of the database
 are required.
 However version 2.x contains a 32-byte field, expected_startbytes which
 can be used for password validation.
 The following box shows the key processing and password validation algorithms
 which differ slightly between 1.x and 2.x versions of KeePass.
 Support for key files in cracking has not been implemented in the initial
 version of KeePass cracker but it can be easily added.
 We have written a custom cracker for KeePass files and following snippet
 shows the main steps involved,
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:keyringpro}KeePass Cracker
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

transform_key(PASSWORD, final_key); /* use custom KDF */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

AES_set_decrypt_key(final_key, 256, &akey);
\end_layout

\begin_layout Plain Layout

if(VERSION == 1) {
\end_layout

\begin_layout Plain Layout

    AES_cbc_encrypt(CIPHERTEXT, PLAINTEXT, SIZE, 
\backslash

\end_layout

\begin_layout Plain Layout

		&akey, IV, AES_DECRYPT);
\end_layout

\begin_layout Plain Layout

	pad_byte = PLAINTEXT[SIZE-1];
\end_layout

\begin_layout Plain Layout

	datasize = cur_salt->contentsize - pad_byte;
\end_layout

\begin_layout Plain Layout

	SHA256_Init(&ctx);
\end_layout

\begin_layout Plain Layout

	SHA256_Update(&ctx, PLAINTEXT, datasize);
\end_layout

\begin_layout Plain Layout

	SHA256_Final(out, &ctx);
\end_layout

\begin_layout Plain Layout

	if(out == CHASH) {
\end_layout

\begin_layout Plain Layout

		/* password found */
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

else {
\end_layout

\begin_layout Plain Layout

	AES_cbc_encrypt(CIPHERTEXT, PLAINTEXT, 32, 
\backslash

\end_layout

\begin_layout Plain Layout

		&akey, iv, AES_DECRYPT);
\end_layout

\begin_layout Plain Layout

	if(memcmp(PLAINTEXT, expected_bytes, 32) == 0)
\end_layout

\begin_layout Plain Layout

		/* password found */
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
We compare the performance of KeePass JtR plug-in on different machines
 below,
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
KeePass cracking benchmarks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/Keyring Benchmarks.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:fib}KeePass cracking benchmarks
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
ttfamily,breaklines=true,columns=flexible,xleftmargin=1pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C]{resources/keepass_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
FloatBarrier
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our work is the only multi-core capable KeePass cracking software available.
 It should be noted that KeePass's usage of using AES in KDF is quite unique.
 Cracking KeePass can be accelerated by using GPU(s) to implement the KDF
 (key derivation function).
 It is possible to port our CPU based KeePass program to run on GPUs by
 using OpenCL.
 We predict a performance improvement > 100X based on our experience with
 Apple's Keychain format.
\end_layout

\begin_layout Section
SSH private keys 
\begin_inset Note Note
status open

\begin_layout Plain Layout
DONE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
SSH is widely used network protocol for secure communication, remote command
 execution and remote shell services among networked computers.
 SSH supports password-based authentication but an attacker can mount a
 MiTM (man-in-the-middle) attack if the unknown public key is verified and
 allowed by the end user.
 In addition, a brute-force attack can be used to discover accounts protected
 by weak passwords.
 So, it if often recommended to use public key authentication instead of
 password-based authentication.
\end_layout

\begin_layout Standard
Private key files generated by ssh-keygen command can be password protected.
 The basic idea behind password protecting the private key files is that
 even if the attacker has access to private key files, he won't be able
 to use them for gaining further access.
 It is possible (and even trivial) to write software for cracking password
 protected private key files.
 A sample program for doing so is shown in Program 
\begin_inset CommandInset ref
LatexCommand ref
reference "prog:sshtrivial"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[H]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:sshtrivial}SSH trivial Cracker
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

process_private_keyfile(filename, PASSWORD)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    BIO *bp;
\end_layout

\begin_layout Plain Layout

    EVP_CIPHER_INFO cipher;
\end_layout

\begin_layout Plain Layout

    EVP_PKEY pk;
\end_layout

\begin_layout Plain Layout

    bp = BIO_new(BIO_s_file());
\end_layout

\begin_layout Plain Layout

    BIO_read_filename(bp, filename);
\end_layout

\begin_layout Plain Layout

    PEM_read_bio(bp, &nm, &header, &data, &len);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    PEM_do_header(&cipher, data, &len, NULL, PASSWORD);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if ((dsapkc = d2i_DSAPrivateKey(NULL, &data, len)) != NULL) {
\end_layout

\begin_layout Plain Layout

	    /* found PASSWORD */
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    else
\end_layout

\begin_layout Plain Layout

	    /* wrong PASSWORD */
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our first version of JtR plug-in (see 
\shape italic
src/ssh_fmt.c
\shape default
) was based on similar technique described above.
 However, it had issues utilizing multiple cores (due to usage of OpenSSL
 functions, some of which are not thread-safe).
 In addition, for larger key sizes the cracking speed was slower (due to
 larger quantity of data being decrypted).
 To avoid such problems, the SSH JtR plug-in was re-designed and re-written
 from scratch.
 
\end_layout

\begin_layout Standard
Instead of using standard key derivations functions like PBKDF2, SSH employs
 a very weak custom KDF shown in Program 
\begin_inset CommandInset ref
LatexCommand ref
reference "prog:sshkdf"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[H]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:sshkdf}SSH custom KDF
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

generate_key_bytes(PASSWORD, REQUIRED_SIZE, final_key)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    unsigned char digest[16] = {0};
\end_layout

\begin_layout Plain Layout

    int keyidx = 0, digest_inited = 0, size = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    while (REQUIRED_SIZE > 0) {
\end_layout

\begin_layout Plain Layout

        MD5_CTX ctx;
\end_layout

\begin_layout Plain Layout

        MD5_Init(&ctx);
\end_layout

\begin_layout Plain Layout

        if (digest_inited)
\end_layout

\begin_layout Plain Layout

            MD5_Update(&ctx, digest, 16);
\end_layout

\begin_layout Plain Layout

        MD5_Update(&ctx, PASSWORD, strlen(PASSWORD));
\end_layout

\begin_layout Plain Layout

        /* use first 8 bytes of salt */
\end_layout

\begin_layout Plain Layout

        MD5_Update(&ctx, SALT, 8);
\end_layout

\begin_layout Plain Layout

        MD5_Final(digest, &ctx);
\end_layout

\begin_layout Plain Layout

        digest_inited = 1;
\end_layout

\begin_layout Plain Layout

        if (REQUIRED_SIZE > 16)
\end_layout

\begin_layout Plain Layout

            size = 16;
\end_layout

\begin_layout Plain Layout

        else 
\end_layout

\begin_layout Plain Layout

            size = REQUIRED_SIZE;
\end_layout

\begin_layout Plain Layout

        /* copy part of digest to keydata */
\end_layout

\begin_layout Plain Layout

        for(i = 0; i < size; i++)
\end_layout

\begin_layout Plain Layout

            final_key[keyidx++] = digest[i];
\end_layout

\begin_layout Plain Layout

        REQUIRED_SIZE -= size;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This allows cracking of password protected private key files at very high
 speeds.
 This custom KDF function drives either 3DES or AES-128 in CBC mode which
 are used for encrypting / decrypting key material.
 We have written a custom cracker for SSH private files and Program 
\begin_inset CommandInset ref
LatexCommand ref
reference "prog:sshalgorithm"

\end_inset

 shows the main steps involved,
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[H]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:sshalgorithm}SSH fast cracker
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

int check_padding_and_structure(out, length)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    pad = out[length - 1];
\end_layout

\begin_layout Plain Layout

    if(pad > 16) return -1; // Bad padding byte
\end_layout

\begin_layout Plain Layout

    n = length - pad;
\end_layout

\begin_layout Plain Layout

    for(i = n; i < length; i++) // check padding
\end_layout

\begin_layout Plain Layout

        if(out[i] != pad) return -1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    /* match structure with known standard structure */
\end_layout

\begin_layout Plain Layout

    outfile = BIO_new(BIO_s_mem());
\end_layout

\begin_layout Plain Layout

    ASN1_parse(outfile, out, legnth, 0);
\end_layout

\begin_layout Plain Layout

    BIO_gets(outfile, (char*)output, N);
\end_layout

\begin_layout Plain Layout

    res = memem(output, 128, "SEQUENCE", 8);
\end_layout

\begin_layout Plain Layout

    if (!res) goto bad;
\end_layout

\begin_layout Plain Layout

    BIO_gets(outfile, (char*)output, N);
\end_layout

\begin_layout Plain Layout

    res = memem(output, 128, ":00", 3);
\end_layout

\begin_layout Plain Layout

    if (!res) goto bad;
\end_layout

\begin_layout Plain Layout

    /* ...
 and some more checks */
\end_layout

\begin_layout Plain Layout

    return 0;
\end_layout

\begin_layout Plain Layout

bad:
\end_layout

\begin_layout Plain Layout

    return -1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

generate_key_bytes(PASSWORD, 16, key);
\end_layout

\begin_layout Plain Layout

AES_set_decrypt_key(key, 128, &akey);
\end_layout

\begin_layout Plain Layout

memcpy(iv, SALT, 16);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// We don't decrypt all the encrypted key material!
\end_layout

\begin_layout Plain Layout

AES_cbc_encrypt(CIPHERTEXT, PLAINTEXT, 32, &akey, iv, AES_DECRYPT);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// 2 blocks (32 bytes) are enough to self-recover 
\end_layout

\begin_layout Plain Layout

// from bad IV, required for correct padding check
\end_layout

\begin_layout Plain Layout

AES_cbc_encrypt(CIPHERTEXT + LENGTH - 32, PLAINTEXT + LENGTH - 32, 
\backslash

\end_layout

\begin_layout Plain Layout

   32, &akey, iv, AES_DECRYPT);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (check_padding_and_structure(PLAINTEXT, LENGTH) == 0)
\end_layout

\begin_layout Plain Layout

    /* Password Found */
\end_layout

\begin_layout Plain Layout

else
\end_layout

\begin_layout Plain Layout

    /* Password was not correct */
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
For more details see 
\shape italic
src/ssh_ng_fmt_plug.c
\shape default
 and 
\shape italic
run/sshng2john.py
\shape default
 in JtR source tree.
 
\end_layout

\begin_layout Standard
The key technique (through which we gain a speed-up of 5X) is that we only
 do partial decryption of encrypted key material.
 After this partial decryption, we employ ASN.1 BER partial decoding to detect
 if the decrypted structure matches the standard key structure.
 RSA private key files have structure { version = 0, n, e, d, p, q, d mod
 p-1, d mod q-1, q**-1 mod p } and DSA private key files have structure
 {version = 0, p, q, g, y, x }.
 We exploit this knowledge (structure of private keys) to detect if decryption
 of key material is correct.
 We haven't found any false positives (so far) by employing the combination
 of partial decryption and decoding.
 To the best of our knowledge, the techniques used by us in cracking password
 protected private keys are original and haven't been described in existing
 research literature.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/SSH Benchmarks.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:fib}SSH cracking benchmarks
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
ttfamily,breaklines=true,columns=flexible,xleftmargin=1pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C]{resources/ssh_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our 
\begin_inset Quotes eld
\end_inset

ssh-ng
\begin_inset Quotes erd
\end_inset

 code running on 1 core is faster than older 
\begin_inset Quotes eld
\end_inset

ssh
\begin_inset Quotes erd
\end_inset

 code running on 8 cores.
 A correct full BER decoding results in data which looks like following
 snippet,
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:fib}Correct BER decoding
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
ttfamily,breaklines=true,columns=flexible,xleftmargin=1pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C]{resources/proper_ber.txt}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
FloatBarrier
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We however only verify the partial key structure (till line number 3).
 The security mechanism used in password protected private keys is quite
 weak.
 We recommend usage of PBKDF2 / bcrypt / crypt as KDF instead of weak MD5
 based custom KDF function to increases resistance against brute-force attacks.
\end_layout

\begin_layout Standard
This work represent the
\shape italic
 state-of-the-art
\shape default
 cracker for SSH password protected private keys.
 
\end_layout

\begin_layout Section
PuTTY private key files 
\begin_inset Note Note
status open

\begin_layout Plain Layout
DONE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
PuTTY is a free Telnet and SSH client for Windows and Unix platforms.
 It is de facto SSH client on Windows platforms.
 Our JtR plug-in and security analysis of PuTTY private key files is based
 on the original research done by Michael Vogt (author of P-ppk-crack, 
\begin_inset CommandInset citation
LatexCommand citealp
key "Vogt:2007"

\end_inset

).
 PuTTY uses a custom file format to store private keys.
\end_layout

\begin_layout Standard
Instead of using standard key derivations functions like PBKDF2, PuTTY employs
 a very weak custom KDF shown in Program 
\begin_inset CommandInset ref
LatexCommand ref
reference "prog:puttykdf"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:puttykdf}PuTTY custom KDF
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

password2key(PASSWORD)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    int passlen = strlen(PASSWORD);
\end_layout

\begin_layout Plain Layout

    unsigned char key[40];
\end_layout

\begin_layout Plain Layout

    SHA_CTX s;
\end_layout

\begin_layout Plain Layout

    SHA1_Init(&s);
\end_layout

\begin_layout Plain Layout

    SHA1_Update(&s, (void*)"
\backslash
0
\backslash
0
\backslash
0
\backslash
0", 4);
\end_layout

\begin_layout Plain Layout

    SHA1_Update(&s, passphrase, passlen);
\end_layout

\begin_layout Plain Layout

    SHA1_Final(key + 0, &s);
\end_layout

\begin_layout Plain Layout

    SHA1_Init(&s);
\end_layout

\begin_layout Plain Layout

    SHA1_Update(&s, (void*)"
\backslash
0
\backslash
0
\backslash
0
\backslash
1", 4);
\end_layout

\begin_layout Plain Layout

    SHA1_Update(&s, passphrase, passlen);
\end_layout

\begin_layout Plain Layout

    SHA1_Final(key + 20, &s);
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    /* variable key now contains AES-256 key */
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This allows cracking of password protected private key files at very high
 speeds.
 This custom KDF function drives AES-256 in CBC mode which is used for encryptin
g / decrypting key material.
 PuTTY private key files have a MAC value which allows us to easily verify
 if we have decrypted the data correctly.
\end_layout

\begin_layout Standard
Program 
\begin_inset CommandInset ref
LatexCommand ref
reference "prog:puttycracker"

\end_inset

 shows the main steps involved in decryption and verification of key material.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:puttycracker}PuTTY cracker
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

unsigned char iv[32] = { 0 };
\end_layout

\begin_layout Plain Layout

AES_set_decrypt_key(key, 256, &akey);
\end_layout

\begin_layout Plain Layout

AES_cbc_encrypt(private_blob, out , private_blob_length, 
\backslash

\end_layout

\begin_layout Plain Layout

	&akey, iv, AES_DECRYPT);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Verify the MAC.
 */
\end_layout

\begin_layout Plain Layout

char realmac[41];
\end_layout

\begin_layout Plain Layout

unsigned char binary[20];
\end_layout

\begin_layout Plain Layout

unsigned char macdata[256];
\end_layout

\begin_layout Plain Layout

int maclen;
\end_layout

\begin_layout Plain Layout

int free_macdata;
\end_layout

\begin_layout Plain Layout

int i;
\end_layout

\begin_layout Plain Layout

unsigned char *p = macdata;
\end_layout

\begin_layout Plain Layout

int namelen = strlen(cur_salt->alg);
\end_layout

\begin_layout Plain Layout

int enclen = strlen(cur_salt->encryption);
\end_layout

\begin_layout Plain Layout

int commlen = strlen(cur_salt->comment);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* ...
 populate maclen and cur_salt */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (cur_salt->is_mac) {
\end_layout

\begin_layout Plain Layout

	SHA_CTX s;
\end_layout

\begin_layout Plain Layout

	unsigned char mackey[20];
\end_layout

\begin_layout Plain Layout

	unsigned int length = 20;
\end_layout

\begin_layout Plain Layout

	char header[] = "putty-private-key-file-mac-key";
\end_layout

\begin_layout Plain Layout

	SHA1_Init(&s);
\end_layout

\begin_layout Plain Layout

	SHA1_Update(&s, header, sizeof(header)-1);
\end_layout

\begin_layout Plain Layout

	if (cur_salt->cipher && passphrase)
\end_layout

\begin_layout Plain Layout

		SHA_Update(&s, passphrase, passlen);
\end_layout

\begin_layout Plain Layout

	SHA1_Final(mackey, &s);
\end_layout

\begin_layout Plain Layout

	hmac_sha1(mackey, 20, macdata, maclen, binary, length);
\end_layout

\begin_layout Plain Layout

	/* HMAC_Init(&ctx, mackey, 20, EVP_sha1());
\end_layout

\begin_layout Plain Layout

	 * HMAC_Update(&ctx, macdata, maclen);
\end_layout

\begin_layout Plain Layout

	 * HMAC_Final(&ctx, binary, &length);
\end_layout

\begin_layout Plain Layout

	 * HMAC_CTX_cleanup(&ctx); */
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

	SHA_Simple(macdata, maclen, binary);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

for (i = 0; i < 20; i++)
\end_layout

\begin_layout Plain Layout

	sprintf(realmac + 2 * i, "%02x", binary[i]);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (strcmp(cur_salt->mac, realmac) == 0)
\end_layout

\begin_layout Plain Layout

	return 1; /* Password Found */
\end_layout

\begin_layout Plain Layout

error:
\end_layout

\begin_layout Plain Layout

	return 0; /* Wrong Password */
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For details see 
\shape italic
src/putty_fmt_plug.c 
\shape default
and
\shape italic
 src/putty2john.c 
\shape default
in JtR source tree.
 We compare the performance of PuTTY JtR plug-in on different machines below,
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
PuTTY cracking benchmarks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/PuTTY Benchmarks.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:fib}PuTTYs cracking benchmarks
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
ttfamily,breaklines=true,columns=flexible,xleftmargin=1pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C]{resources/putty_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
FloatBarrier
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our work is the only multi-core capable PuTTY cracking software available.
 Cracking PuTTY password protected private keys can be accelerated by using
 GPU(s) to implement the KDF (key derivation function).
 
\end_layout

\begin_layout Section
Apple Legacy FileVault & Mac OS X DMG files 
\begin_inset Note Note
status open

\begin_layout Plain Layout
DONE
\end_layout

\end_inset


\end_layout

\begin_layout Standard
FileVault is a method of using encryption with volumes on Apple Mac computers
 which does encryption and decryption on the fly 
\begin_inset CommandInset citation
LatexCommand citep
key "Apple:2003"

\end_inset

.
 FileVault is used by password protected Mac OS X disk image files.
 Legacy FileVault supports two different header formats v1 and v2 with v1
 being largely obsolete under modern Mac systems.
 Our JtR plug-in and security analysis of Apple Legacy FileVault and Mac
 OS X disk image files is an extension of the original research published
 in the VileFault paper
\begin_inset CommandInset citation
LatexCommand citep
key "Appelbauman:2006"

\end_inset

.
 However the information present in VileFault paper is correct (to some
 extent) only for the v1 format.
 The source code published along VileFault paper does not work for v2 format
 images nor for images using AES-256 encryption.
 We have fixed these shortcomings in our current work.
 This work was done in collaboration with Milen Rangelov (author of hashkill,
 
\begin_inset CommandInset citation
LatexCommand citep
key "Rangelov:2010"

\end_inset

).
\end_layout

\begin_layout Standard
The key used to encrypt data is encrypted (“wrapped”) and stored in the
 header region of the disk image.
 Wrapping (encryption) of keys done using 3DES-EDE.
 Wrapped Key = 3DES-EDE(derived_key, IV, Actual Encryption Key) where derived_ke
y = PBKDF2(salt, User Password, iterations).
 Be default, 1000 iterations are used and there is no option for changing
 this value.
\end_layout

\begin_layout Standard
Data blocks are encrypted in 4KiB “chunks” using AES-128 or AES-256 in CBC
 mode using the decrypted (un-wrapped) Wrapped Key.
 The IV is output of HMAC-SHA1 which takes the chunk number and Hmac-sha1
 key read from the header.
 Encrypted Data Chunk = AES(Decrypted Wrapped Key, IV, chunkno, AES_ENCRYPT)
 where IV = trunc128 (HMAC-SHA1(hmac-key || chunkno).
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:filevault"

\end_inset

 shows describes the v2 file format used by Apple's Legacy FileVault.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%optional [t, b or h];
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="14" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="6.5cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Length
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Purpose
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kdf_algorithm
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Specifies PBKDF2 algorithm used
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kdf_prng_algorithm
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
- 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kdf_iteration_count
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PBKDF2 iterations parameter (Currently 1000)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kdf_salt_len
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Salt Length
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kdf_salt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Salt Value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
blob_enc_iv_size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size of IV used while wrapping key
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
blob_enc_iv
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IV used while wrapping key
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
blob_enc_key_bits
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Key Size of Encryption Algorithm (Currently 168 bits)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
blob_enc_algorithm
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encryption Algorithm Used (Currently 3DES)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
blob_enc_padding
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Specifies padding mode
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
blob_enc_mode
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encryption mode used (Currently CBC)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
encrypted_keyblob_size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size of Encrypted Key
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
48 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
encrypted_keyblob
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted (using 3DES)Key
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:filevault"

\end_inset

 Legacy FileVault v2 format
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Program 
\begin_inset CommandInset ref
LatexCommand ref
reference "psc:dmg-algorithm"

\end_inset

 demonstrates the PBKDF2 derived_key derivation from user password, Actual
 Encryption Key un-wrapping by using derived_key and decryption of encrypted
 data.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:dmg-algorithm}dmg decryption
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

AES_KEY aes_decrypt_key;
\end_layout

\begin_layout Plain Layout

       
\end_layout

\begin_layout Plain Layout

/* derive dervied_key from user password, this is 
\end_layout

\begin_layout Plain Layout

 * used in un-wrapping operation */
\end_layout

\begin_layout Plain Layout

pbkdf2(UserPassword, strlen(UserPassword), salt, 20, 
\backslash

\end_layout

\begin_layout Plain Layout

	1000, derived_key);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* decrypt encrypted_keyblob (the wrapped key), 
\end_layout

\begin_layout Plain Layout

 * un-wrap operation */
\end_layout

\begin_layout Plain Layout

DES_ede3_cbc_encrypt(encrypted_keyblob, decrypted_key, 
\backslash

\end_layout

\begin_layout Plain Layout

	DES_key_schedule values..., IV, DES_DECRYPT);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* un-wrapped key (decrypted_key) is used now for data 
\end_layout

\begin_layout Plain Layout

   decryption.
 Derive IV to be used in AES decryption 
\end_layout

\begin_layout Plain Layout

   based on chunk number to be decrypted */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

memcpy(aes_key, decrypted_key, 32);
\end_layout

\begin_layout Plain Layout

memcpy(hmacsha1_key, decrypted_key, 20);
\end_layout

\begin_layout Plain Layout

HMAC_CTX_init(&ctx);
\end_layout

\begin_layout Plain Layout

HMAC_Init_ex(&ctx, hmacsha1_key, 20, EVP_sha1(), NULL);
\end_layout

\begin_layout Plain Layout

HMAC_Update(&ctx, ChunkNumber, 4);
\end_layout

\begin_layout Plain Layout

HMAC_Final(&ctx, iv);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Decrypt chunk using derived iv and derived AES key */
\end_layout

\begin_layout Plain Layout

AES_set_decrypt_key(aes_key, 128, &aes_decrypt_key);
\end_layout

\begin_layout Plain Layout

AES_cbc_encrypt(chunk, data, data_size, &aes_decrypt_key, 
\backslash

\end_layout

\begin_layout Plain Layout

	iv, AES_DECRYPT);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* data now contains decrypted data */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The original heuristics used in VileFault paper to detect if the decryption
 happened successfully were totally wrong.
 We have identified a new set of proper heuristics which are capable of
 detecting where the data was decrypted successfully.
 The following snippet shows our new heuristics functions.
\end_layout

\begin_layout Standard
Program 
\begin_inset CommandInset ref
LatexCommand ref
reference "psc:dmg-algorithm"

\end_inset

 demonstrates the PBKDF2 derived_key derivation from user password, Actual
 Encryption Key un-wrapping by using derived_key and decryption of encrypted
 data.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:dmg-check}dmg decryption heuristics
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

/* a return code of 1 indicates a successful decryption */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

int verify_decrytion(data)
\end_layout

\begin_layout Plain Layout

{       
\end_layout

\begin_layout Plain Layout

   r = memmem(data, data_length, (void*)"koly", 4);
\end_layout

\begin_layout Plain Layout

   if(r) {
\end_layout

\begin_layout Plain Layout

       unsigned int *u32Version = (unsigned int *)(r + 4);
\end_layout

\begin_layout Plain Layout

       if(HTONL(*u32Version) == 4)
\end_layout

\begin_layout Plain Layout

           return 1;
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

   if(memmem(data, data_length, (void*)"EFI PART", 8))
\end_layout

\begin_layout Plain Layout

       return 1;
\end_layout

\begin_layout Plain Layout

   if(memmem(data, data_length, (void*)"Apple", 5)) {
\end_layout

\begin_layout Plain Layout

       return 1;
\end_layout

\begin_layout Plain Layout

   if(memmem(data, data_length, (void*)"Press any key to reboot", 23)) 
\end_layout

\begin_layout Plain Layout

       return 1;
\end_layout

\begin_layout Plain Layout

   return 0; /* incorrect decryption */
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For details see
\shape italic
 src/dmg_fmt_plug.c
\shape default
 and 
\shape italic
src/dmg2john.c 
\shape default
in JtR source tree.
 We compare the performance of DMG JtR plug-in on different machines below,
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
DMG cracking benchmarks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/DMG Benchmarks.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We compare the performance of dmg JtR plug-in on different machines below,
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:fib}dmg cracking benchmarks
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
ttfamily,breaklines=true,columns=flexible,xleftmargin=1pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C]{resources/dmg_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
FloatBarrier
\end_layout

\end_inset


\end_layout

\begin_layout Standard
XXX dmg format helped CTO.
\end_layout

\begin_layout Section
AES encrypted ZIP files 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Improve Me
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Zip is a popular file format used for data compression and archiving.
 Zip file format also supports encryption of data.
 The traditional encryption algorithm used in the Zip file format is weak
 and plenty of softwares exist to crack it.
 Support for strong AES encryption for ZIP archives was added in WinZip
 9.0 which was released in year 2004.
 AES encryption as used in WinZip is described in 
\begin_inset CommandInset citation
LatexCommand cite
key "WinZip"

\end_inset

.
 For details about Zip file format, see APPNOTE.TXT 
\begin_inset CommandInset citation
LatexCommand cite
key "APPNOTE"

\end_inset

 document.
 Table XXX only describes the fields relevant to password cracking.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%optional [t, b or h];
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="middle" width="2.5cm">
<column alignment="left" valignment="middle" width="1.5cm">
<column alignment="left" valignment="middle" width="5cm">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Salt
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 / 12 / 16 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Salt size is dependent on Key Size 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Password verification value
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 byte string used to validate correct password
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted file data
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Variable
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Actual encrypted file data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Authentication code
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Authentication code
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:zip"

\end_inset

 ZIP Encrypted file storage format
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The "salt" or "salt value" is a random or pseudo-random sequence of bytes
 that is combined with the encryption password to create encryption and
 authentication key.
 This two-byte value is produced as part of the process that derives the
 encryption and decryption keys from the password.
 When encrypting, a verification value is derived from the encryption password
 and stored with the encrypted file.
 Before decrypting, a verification value can be derived from the decryption
 password and compared to the value stored with the file, serving as a quick
 check that will detect most, but not all, incorrect passwords.
 There is a 1 in 65,536 chance that an incorrect password will yield a matching
 verification value; therefore, a matching verification value cannot be
 absolutely relied on to indicate a correct password.
 Encryption is applied only to the content of files.
 It is performed after compression, and not to any other associated data.
 The file data is encrypted byte-for-byte using the AES encryption algorithm
 operating in "CTR" mode 
\begin_inset CommandInset citation
LatexCommand cite
key "WinZip"

\end_inset

.
\end_layout

\begin_layout Standard
It is important to note that 
\begin_inset Quotes eld
\end_inset

Authentication code
\begin_inset Quotes erd
\end_inset

 is message authentication code (or MAC) of the data in the file after compressi
on and encryption.
 Hence, it can't be used for verifying if the decryption happened correctly.
\end_layout

\begin_layout Standard
Program 
\begin_inset CommandInset ref
LatexCommand ref
reference "psc:dmg-algorithm"

\end_inset

 XXX.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:dmg-check}AES ZIP cracking algorithm
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

AES_KEY aes_decrypt_key;
\end_layout

\begin_layout Plain Layout

       
\end_layout

\begin_layout Plain Layout

/* derive dervied_key from user password, this 
\end_layout

\begin_layout Plain Layout

 * is used in un-wrapping operation */
\end_layout

\begin_layout Plain Layout

pbkdf2(UserPassword, strlen(UserPassword), salt, 
\backslash

\end_layout

\begin_layout Plain Layout

	20, 1000, derived_key);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* decrypt encrypted_keyblob (the wrapped key), 
\end_layout

\begin_layout Plain Layout

 * un-wrap operation */
\end_layout

\begin_layout Plain Layout

DES_ede3_cbc_encrypt(encrypted_keyblob, decrypted_key, 
\backslash

\end_layout

\begin_layout Plain Layout

	DES_key_schedule values..., IV, DES_DECRYPT);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* un-wrapped key (decrypted_key) is used now for data 
\end_layout

\begin_layout Plain Layout

 * decryption, derive IV to be used in AES decryption 
\end_layout

\begin_layout Plain Layout

 * based on chunk number to be decrypted */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

memcpy(aes_key, decrypted_key, 32);
\end_layout

\begin_layout Plain Layout

memcpy(hmacsha1_key, decrypted_key, 20);
\end_layout

\begin_layout Plain Layout

HMAC_CTX_init(&ctx);
\end_layout

\begin_layout Plain Layout

HMAC_Init_ex(&ctx, hmacsha1_key, 20, EVP_sha1(), NULL);
\end_layout

\begin_layout Plain Layout

HMAC_Update(&ctx, ChunkNumber, 4);
\end_layout

\begin_layout Plain Layout

HMAC_Final(&ctx, iv);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Decrypt chunk using derived iv and derived AES key */
\end_layout

\begin_layout Plain Layout

AES_set_decrypt_key(aes_key, 128, &aes_decrypt_key);
\end_layout

\begin_layout Plain Layout

AES_cbc_encrypt(chunk, data, data_size, &aes_decrypt_key, 
\backslash

\end_layout

\begin_layout Plain Layout

	iv, AES_DECRYPT);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* data now contains decrypted data */
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For more details see 
\shape italic
src/zip_fmt_plug.c
\shape default
 and
\shape italic
 src/zip2john.c
\shape default
 in JtR source tree.
 We compare the performance of ZIP JtR plug-in on different machines below,
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ZIP cracking benchmarks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/ZIP Benchmarks.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:fib}ZIP cracking benchmarks
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
ttfamily,breaklines=true,columns=flexible,xleftmargin=1pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C]{resources/zip_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
FloatBarrier
\end_layout

\end_inset


\end_layout

\begin_layout Section
PGP / GPG Secret Keys 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Progress
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pretty Good Privacy (PGP) is a data encryption and decryption computer program
 that provides cryptographic privacy and authentication for data communication.
 PGP is often used for signing, encrypting and decrypting texts, e-mails,
 files, directories and whole disk partitions to increase the security of
 e-mail communications 
\begin_inset CommandInset citation
LatexCommand cite
key "PGP basics"

\end_inset

.
 PGP and GnuPG follow the OpenPGP standard (RFC 4880) for encrypting and
 decrypting data.
 Our JtR plug-in and security analysis of PGP private key files is based
 on the original research done by Jonas Gehring (author of pgpry 
\begin_inset CommandInset citation
LatexCommand citep
key "Gehring:2010"

\end_inset

)
\end_layout

\begin_layout Standard
PGP secret keys can be password protected.
 The basic idea behind password protecting the secret key files is that
 even if the attacker has access to the secret key files, he won't be able
 to use them for gaining further access.
 
\end_layout

\begin_layout Standard
PGP / GPG use various custom key derivation functions with variable number
 of iterations to deter brute-force attacks.
 PGP calls its custom custom key derivation functions as string-to-key (s2k)
 functions.
 The various s2k functions vary a lot in their speed and resistance to brute-for
ce attacks.
 A weak s2k function is shown in Program 
\begin_inset CommandInset ref
LatexCommand ref
reference "prog:gpg-weak-kdf"

\end_inset

 XXX.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:gpg-weak-kdf}PGP custom KDF
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

S2KSimpleMD5Generator(char *password, unsigned char *key, int length)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    MD5_CTX ctx;
\end_layout

\begin_layout Plain Layout

    uint32_t numHashes = (length + MD5_DIGEST_LENGTH - 1) / MD5_DIGEST_LENGTH;
\end_layout

\begin_layout Plain Layout

    int i, j;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (i = 0; i < numHashes; i++) {
\end_layout

\begin_layout Plain Layout

        MD5_Init(&ctx);
\end_layout

\begin_layout Plain Layout

        for (j = 0; j < i; j++) {
\end_layout

\begin_layout Plain Layout

            MD5_Update(&ctx, "
\backslash
0", 1);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        MD5_Update(&ctx, password, strlen(password));
\end_layout

\begin_layout Plain Layout

        MD5_Final(key + (i * MD5_DIGEST_LENGTH), &ctx);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is possible to mount time-memory trade-off attacks against such simple
 s2k functions due to lack of any salting.
 This allows cracking of password protected private key files at very high
 speeds.
 Such weak s2k functions are no longer used even in the default configuration
 of GPG.
 .
 The default s2k function is shown in Program 
\begin_inset CommandInset ref
LatexCommand ref
reference "prog:gpg-default-kdf"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:gpg-default-kdf}PGP custom KDF
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

S2KItSaltedSHA1Generator(char *password, unsigned char *key, int length)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    unsigned char keybuf[KEYBUFFER_LENGTH];
\end_layout

\begin_layout Plain Layout

    SHA_CTX ctx;
\end_layout

\begin_layout Plain Layout

    int i, j;
\end_layout

\begin_layout Plain Layout

    int32_t tl;
\end_layout

\begin_layout Plain Layout

    int32_t mul;
\end_layout

\begin_layout Plain Layout

    int32_t bs;
\end_layout

\begin_layout Plain Layout

    uint8_t *bptr;
\end_layout

\begin_layout Plain Layout

    int32_t n;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    uint32_t numHashes = (length + SHA_DIGEST_LENGTH - 1) / SHA_DIGEST_LENGTH;
\end_layout

\begin_layout Plain Layout

    memcpy(keybuf, cur_salt->salt, 8);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    for (i = 0; i < numHashes; i++) {
\end_layout

\begin_layout Plain Layout

        SHA1_Init(&ctx);
\end_layout

\begin_layout Plain Layout

        for (j = 0; j < i; j++) {
\end_layout

\begin_layout Plain Layout

            SHA1_Update(&ctx, "
\backslash
0", 1);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        // Find multiplicator
\end_layout

\begin_layout Plain Layout

        tl = strlen(password) + 8;
\end_layout

\begin_layout Plain Layout

        mul = 1;
\end_layout

\begin_layout Plain Layout

        while (mul < tl && ((64 * mul) % tl)) {
\end_layout

\begin_layout Plain Layout

            ++mul;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        // Try to feed the hash function with 64-byte blocks
\end_layout

\begin_layout Plain Layout

        bs = mul * 64;
\end_layout

\begin_layout Plain Layout

        bptr = keybuf + tl;
\end_layout

\begin_layout Plain Layout

        n = bs / tl;
\end_layout

\begin_layout Plain Layout

        memcpy(keybuf + 8, password, strlen(password));
\end_layout

\begin_layout Plain Layout

        while (n-- > 1) {
\end_layout

\begin_layout Plain Layout

            memcpy(bptr, keybuf, tl);
\end_layout

\begin_layout Plain Layout

            bptr += tl;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        n = cur_salt->count / bs;
\end_layout

\begin_layout Plain Layout

        while (n-- > 0) {
\end_layout

\begin_layout Plain Layout

            SHA1_Update(&ctx, keybuf, bs);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        SHA1_Update(&ctx, keybuf, cur_salt->count % bs);
\end_layout

\begin_layout Plain Layout

        SHA1_Final(key + (i * SHA_DIGEST_LENGTH), &ctx);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have written a custom cracker for GPG secret key files and Program 
\begin_inset CommandInset ref
LatexCommand ref
reference "prog:gpg-cracker"

\end_inset

 shows the main steps involved.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:gpg-cracker}PGP Cracker
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minted}[linenos=false]{c}
\end_layout

\begin_layout Plain Layout

/* derive decryption key from PASSWORD and SALT using custom KDF */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

S2KItSaltedSHA1Generator(char *password, unsigned char *key, int length);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

S2KItSaltedSHA1Generator(PASSWORD, keydata, KEY_SIZE);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* decrypt encrypted key material */
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Decrypt first data block in order to check the first two bits of
\end_layout

\begin_layout Plain Layout

// the MPI.
 If they are correct, there's a good chance that the
\end_layout

\begin_layout Plain Layout

// password is correct, too.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

unsigned char ivec[32];
\end_layout

\begin_layout Plain Layout

unsigned char out[4096];
\end_layout

\begin_layout Plain Layout

int tmp = 0;
\end_layout

\begin_layout Plain Layout

uint32_t num_bits;
\end_layout

\begin_layout Plain Layout

int checksumOk;
\end_layout

\begin_layout Plain Layout

int i;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Quick Hack
\end_layout

\begin_layout Plain Layout

memcpy(ivec, cur_salt->iv, blockSize(cur_salt->cipher_algorithm));
\end_layout

\begin_layout Plain Layout

CAST_KEY ck;
\end_layout

\begin_layout Plain Layout

CAST_set_key(&ck, ks, keydata);
\end_layout

\begin_layout Plain Layout

CAST_cfb64_encrypt(cur_salt->data, out, CAST_BLOCK, &ck, ivec, &tmp, CAST_DECRYP
T);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

num_bits = ((out[0] << 8) | out[1]);
\end_layout

\begin_layout Plain Layout

if (num_bits < MIN_BN_BITS || num_bits > cur_salt->bits) {
\end_layout

\begin_layout Plain Layout

   return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Decrypt all data
\end_layout

\begin_layout Plain Layout

memcpy(ivec, cur_salt->iv, blockSize(cur_salt->cipher_algorithm));
\end_layout

\begin_layout Plain Layout

tmp = 0;
\end_layout

\begin_layout Plain Layout

CAST_KEY ck;
\end_layout

\begin_layout Plain Layout

CAST_set_key(&ck, ks, keydata);
\end_layout

\begin_layout Plain Layout

CAST_cfb64_encrypt(cur_salt->data, out, cur_salt->datalen, &ck, ivec, &tmp,
 CAST_DECRYPT);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Verify
\end_layout

\begin_layout Plain Layout

checksumOk = 0;
\end_layout

\begin_layout Plain Layout

uint8_t checksum[SHA_DIGEST_LENGTH];
\end_layout

\begin_layout Plain Layout

SHA_CTX ctx;
\end_layout

\begin_layout Plain Layout

SHA1_Init(&ctx);
\end_layout

\begin_layout Plain Layout

SHA1_Update(&ctx, out, cur_salt->datalen - SHA_DIGEST_LENGTH);
\end_layout

\begin_layout Plain Layout

SHA1_Final(checksum, &ctx);
\end_layout

\begin_layout Plain Layout

if (memcmp(checksum, out + cur_salt->datalen - SHA_DIGEST_LENGTH, SHA_DIGEST_LEN
GTH) == 0) {
\end_layout

\begin_layout Plain Layout

   checksumOk = 1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// If the checksum is ok, try to parse the first MPI of the private key
\end_layout

\begin_layout Plain Layout

if (checksumOk) {
\end_layout

\begin_layout Plain Layout

   BIGNUM *b = NULL;
\end_layout

\begin_layout Plain Layout

   uint32_t blen = (num_bits + 7) / 8;
\end_layout

\begin_layout Plain Layout

   if (blen < cur_salt->datalen && ((b = BN_bin2bn(out + 2, blen, NULL))
 != NULL)) {
\end_layout

\begin_layout Plain Layout

      BN_free(b);
\end_layout

\begin_layout Plain Layout

      return 1;
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

return 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{minted}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For details see
\shape italic
 src/gpg_fmt_plug.c
\shape default
 and
\shape italic
 src/gpg2john.cpp
\shape default
 in JtR source tree.
 
\end_layout

\begin_layout Standard
The key technique (through which we gain a speed-up) is that we only do
 partial decryption (1 block) of encrypted key material and then check.
 <FIXME>
\end_layout

\begin_layout Standard
Our CPU version of the cracking software achieves around 896 c/s on a single
 core and 7097 c/s on 2 x Xeon E5420 (8 cores total).
 The GPU versionachieves a speedup of around 97x over single core CPU result.
 Currently, the GPU implementation transfers candidate passwords from CPU
 to GPU which is sub-optimal.
 Future version of JtR will remove this limitation and higher cracking speeds
 can be expected.
 We compare the performance of PGP JtR plug-in on different machines below,
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
GPG Benchmarks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/Agile Keychain Benchmarks.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{Program}[h]
\end_layout

\begin_layout Plain Layout


\backslash
caption{
\backslash
label{prog:fib}ZIP cracking benchmarks
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
ttfamily,breaklines=true,columns=flexible,xleftmargin=1pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C]{resources/pgp_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
end{Program}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
FloatBarrier
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Cracking password protected GPG private key files is extensively analyzed
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "milo2011.pdf"

\end_inset

.
 However, Milo et al, haven't released any source code demonstrating the
 speedups they claim in the paper and asking for more information about
 testing enviornment resulted in no answer.
\end_layout

\begin_layout Section
EncFS 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Progress
\end_layout

\end_inset


\end_layout

\begin_layout Standard
1Password is a popular password manager available for Windows, iPad, iPhone,
 Android and Mac platforms.
 1Password uses a file format (called Agile Keychain format) which is different
 from Apple's Keychain file format.
 The goal of the Agile Keychain file is to build on the successes of the
 Mac OS X keychain while increasing the flexibility and portability of the
 keychain design 
\begin_inset CommandInset citation
LatexCommand cite
key "Agile Keychain Design"

\end_inset

.
 1Password stores its data in a folder called 
\begin_inset Quotes eld
\end_inset

1Password.agilekeychain
\begin_inset Quotes erd
\end_inset

.
 1Password uses JSON (JavaScript Object Notation) format to store its data
 which has a benefit that its files can be loaded directly into a web browser.
 It is possible to access the data, without installing 1Password software
 , by using a web browser.
 Our JtR plug-in and security analysis of Agile Keychain is an extension
 of the original research done by Antonin Amand (author of agilekeychain
 
\begin_inset CommandInset citation
LatexCommand cite
key "agilekeychain"

\end_inset

)
\end_layout

\begin_layout Standard
The core of the encryption is AES (Advanced Encryption Standard) using 128-bit
 encryption keys and performed in Cipher Block Chaining (CBC) mode along
 with a randomized Initialization Vector.
 Instead of encrypting data with the password directly, a random key of
 1024 bytes is used.
 This key is stored in the encryptionKeys.js file, encrypted using a key
 derived from the users master password by using PBKDF2 function.
 A sample encryptionKeys.js is shown below,
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=none,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C,title=Sample encryptionKeys.js]{resources/ekjs.js}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have written a Python program (run/agilekc2john.py) which parses Agile
 Keychain data and generates a 
\begin_inset Quotes eld
\end_inset

hash
\begin_inset Quotes erd
\end_inset

 which is understood by JtR.
 1Password uses PKCS#7 padding for wrapping the random encryption key.
 We exploit this padding knowledge to figure out if we have successfully
 decrypted the radom encryption key.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Agile Keychain Benchmarks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/Agile Keychain Benchmarks.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C,title=Agile Keychain Cracker]{resources/agilekeychain
_metadata.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=none,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=Agile Keychain Benchmarks]{resources/agileke
ychain_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In our opinion, the default number of iterations (1,000) should be increased
 for added security against brute-force attacks.
 It is trivial to do so by increasing the value of 
\begin_inset Quotes eld
\end_inset

iterations
\begin_inset Quotes erd
\end_inset

 parmater in encryptionKey.ks file.
 Our cracker is the only known cracker for Agile Keychain files.
 Agile Keychain design has one flaw that it doesn't encrypt and protect
 the metadata (like URL) for a given password.
 This opens up another attack vector against 1Password software.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=none,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=Agile Keychain metadata flaw]{resources/agil
ekeychain_metadata.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
FloatBarrier
\end_layout

\end_inset


\end_layout

\begin_layout Standard
XXX
\end_layout

\begin_layout Section
Microsoft Office file formats 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Progress
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Analysis of Outlook (97-2013) pst files
\end_layout

\begin_layout Standard
Personal Storage Table (PST) is an open, proprietary file format used to
 store messages, calendar events, and other items within Microsoft software
 such as Microsoft Exchange Client, Windows Messaging, and Microsoft Outlook
 
\begin_inset CommandInset citation
LatexCommand cite
key "PST"

\end_inset

.
 Password protection can be used to protect the content of the PST files.
 However, even Microsoft itself admits that the password adds very little
 protection, due to the existence of commonly available tools which can
 remove or simply bypass the password protection.
 The password to access the table is stored itself in the PST file.
 Outlook checks to make sure that it matches the user-specified password
 and refuses to operate if there is no match.
\end_layout

\begin_layout Standard
PST is a complex files format 
\end_layout

\begin_layout Standard
The data is readable by the libpst project code.
\end_layout

\begin_layout Standard
Microsoft (MS) offers three values for the encryption setting: none, compressibl
e, and high.
\end_layout

\begin_layout Standard
None the PST data is stored as plain text.
 Compressible the PST data is encrypted with a byte-substitution cipher
 with a fixed substitution table.
 High (sometimes called "better") encryption is similar to a WWII German
 Enigma cipher with three fixed rotors.
\end_layout

\begin_layout Standard
Note that neither of the two encryption modes uses the user-specified password
 as any part of the key for the encryption.
\end_layout

\begin_layout Standard
http://linux.die.net/man/5/outlook.pst
\end_layout

\begin_layout Standard
The following item types are known, but not all of these are implemented
 in the code yet.
 
\end_layout

\begin_layout Standard
0x67ff Password checksum,
\end_layout

\begin_layout Standard
CRC algorithm : http://msdn.microsoft.com/en-us/library/ff385753%28v=office.12%29
\end_layout

\begin_layout Standard
http://www.passcape.com/outlook_passwords#b2
\end_layout

\begin_layout Standard
The Open Document Format for Office Applications (ODF), also known as OpenDocume
nt (OD), is an XML-based file format for spreadsheets, charts, presentations
 and word processing documents.
 Our work is the first open-source multi-core cracking software for ODF
 files.
 Uses PBKDF2.
 OpenDocument files can also take the format of a ZIP compressed archive
 containing a number of files and directories; these can contain binary
 content and benefit from ZIP's lossless compression to reduce.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
manifest.xml snipped sample
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/odf-manifest-final.png
	scale 65

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Benchmarks, 
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=ODF cracking benchmarks]{resources/odf_outpu
t.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
http://cpan.uwinnipeg.ca/htdocs/Spreadsheet-ParseExcel/Spreadsheet/ParseExcel.pm.htm
l#Decryption
\end_layout

\begin_layout Standard
http://www.password-crackers.com/blog/?p=16
\end_layout

\begin_layout Standard
http://www.password-crackers.com/en/articles/12/#II
\end_layout

\begin_layout Subsection
Guaranteed decryption of Office files using 40-bit RC4 encryption
\end_layout

\begin_layout Standard
The Open Document Format for Office Applications (ODF), also known as OpenDocume
nt (OD), is an XML-based file format for spreadsheets, charts, presentations
 and word processing documents.
 Our work is the first open-source multi-core cracking software for ODF
 files.
 Uses PBKDF2.
 OpenDocument files can also take the format of a ZIP compressed archive
 containing a number of files and directories; these can contain binary
 content and benefit from ZIP's lossless compression to reduce Benchmarks,
 
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=ODF cracking benchmarks]{resources/odf_outpu
t.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Office 2003 file encryption
\end_layout

\begin_layout Subsection
Office 2007 file encryption
\end_layout

\begin_layout Standard
The Open Document Format for Office Applications (ODF), also known as OpenDocume
nt (OD), is an XML-based file format for spreadsheets, charts, presentations
 and word processing documents.
 Our work is the first open-source multi-core cracking software for ODF
 files.
 Uses PBKDF2.
 OpenDocument files can also take the format of a ZIP compressed archive
 containing a number of files and directories; these can contain binary
 content and benefit from ZIP's lossless compression to reduce.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
manifest.xml snipped sample
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/odf-manifest-final.png
	scale 65

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Benchmarks, 
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=ODF cracking benchmarks]{resources/odf_outpu
t.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Office 2010 file encryption
\end_layout

\begin_layout Standard
The Open Document Format for Office Applications (ODF), also known as OpenDocume
nt (OD), is an XML-based file format for spreadsheets, charts, presentations
 and word processing documents.
 Our work is the first open-source multi-core cracking software for ODF
 files.
 Uses PBKDF2.
 OpenDocument files can also take the format of a ZIP compressed archive
 containing a number of files and directories; these can contain binary
 content and benefit from ZIP's lossless compression to reduce.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
manifest.xml snipped sample
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/odf-manifest-final.png
	scale 65

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Benchmarks, 
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=ODF cracking benchmarks]{resources/odf_outpu
t.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Construct 2 file format tables from office2john.c.
\end_layout

\begin_layout Subsection
Office 2013 file encryption
\end_layout

\begin_layout Standard
The Open Document Format for Office Applications (ODF), also known as OpenDocume
nt (OD), is an XML-based file format for spreadsheets, charts, presentations
 and word processing documents.
 Our work is the first open-source multi-core cracking software for ODF
 files.
 Uses PBKDF2.
 OpenDocument files can also take the format of a ZIP compressed archive
 containing a number of files and directories; these can contain binary
 content and benefit from ZIP's lossless compression to reduce.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
manifest.xml snipped sample
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/odf-manifest-final.png
	scale 65

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Benchmarks, 
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=ODF cracking benchmarks]{resources/odf_outpu
t.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Analysis of OpenOffice / LibreOffice file format 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Progress
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Open Document Format for Office Applications (ODF), also known as OpenDocume
nt (OD), is an XML-based file format for spreadsheets, charts, presentations
 and word processing documents.
 Our work is the first open-source multi-core cracking software for ODF
 files.
 Uses PBKDF2.
 OpenDocument files can also take the format of a ZIP compressed archive
 containing a number of files and directories; these can contain binary
 content and benefit from ZIP's lossless compression to reduce.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
manifest.xml snipped sample
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/odf-manifest-final.png
	scale 65

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Benchmarks, 
\end_layout

\begin_layout Standard
We compare the performance of ODF JtR plug-in on different machines below,
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ODFcracking benchmarks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/Agile Keychain Benchmarks.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=ODF cracking benchmarks]{resources/odf_outpu
t.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
By using techniques described in this section, it is possible to write a
 cracker for earlier version of ODF files.
 See run/sxc2john.py and src/sxc_fmt_plug.c file in JtR source tree.
\end_layout

\begin_layout Section
Analysis of PDF files 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Progress
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Analysis of PDF files using RC4 encryption
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
ttfamily,breaklines=true,numbers=left,columns=flexible,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C,caption=PDF RC4 Cracker]{resources/pdf_rc4_cracker.c}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Guaranteed decryption of PDF files using 40-bit RC4 encryption
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
ttfamily,breaklines=true,numbers=left,columns=flexible,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C,caption=PDF 40-bit RC4 Cracker]{resources/pdf_suresho
t_cracker.c}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Adobe Acrobat 9 encrypted files (R5 algorithm)
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
ttfamily,breaklines=true,numbers=left,columns=flexible,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C,caption=PDF 40-bit RC4 Cracker]{resources/pdf_suresho
t_cracker.c}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Analysis of Adobe Acrobat 10 and 11 encrypted files (R6 algorithm)
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
ttfamily,breaklines=true,numbers=left,columns=flexible,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C,caption=PDF 40-bit RC4 Cracker]{resources/pdf_suresho
t_cracker.c}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Comparison of various KDF functions used in Adobe Acrobat
\end_layout

\begin_layout Standard
We compare the performance of ODF JtR plug-in on different machines below,
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ODFcracking benchmarks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/Agile Keychain Benchmarks.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
RAR files.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Progress
\end_layout

\end_inset


\end_layout

\begin_layout Standard
RAR stands for Roshal ARchive and it is a proprietary archive file format
 that supports data compression, error recovery, and file spanning.
 RAR is a highly popular compression format embraced even by the software
 cracking scene.
 The RAR file format is well documented in technote.txt.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
RAR file format
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="middle" width="2.5cm">
<column alignment="left" valignment="middle" width="2.5cm">
<column alignment="left" valignment="middle" width="6cm">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Magic
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x9AA2D903, Magic
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Version
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xB54BFB67, Magic
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cipher Name
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Determine what algorithms are used 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cipher Mode
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Version of the database format 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hash Spec
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Initial random number to start on the sha256 of the key 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Payload Offset
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Initialization vector used for all algorithms 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Key Bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted 128 random value using P’ with Twofish algorithm
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mkDigest 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SHA1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mkDigestSalt
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bytes 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SHA256 hash of only the contents (entire file minus starting 124 bytes)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mkDigestIterations
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of iterations in Phttp://en.wikipedia.org/wiki/Personal_Storage_TableBKDF2
 function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UUID 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
40
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of rounds to do AES block encryption on the Master Key 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
keyblock structure (8 entries)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
48 bytes each
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
Where, keyblock structure has the following format,
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
active
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
denotes whether this key slot is active or not
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
passwordIterations
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
parameters used for password processing
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
passwordSalt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
parameters used for password processing
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
keyMaterialOffset
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
parameters used for AF store/load
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
stripes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
parameters used for AF store/load
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
RAR can encrypt data in two different way: First, in "-hp" mode, both file
 data and file headers (which contains file names and other metadata) are
 encrypted.
 Encryption algorithm is changed to cipher block chaining (CBC) mode over
 AES (Advanced Encryption Standard) with 128 bit key length.Encryption of
 both file data and file headers.
 RAR uses custom key stretching algorithm to deter brute-force attacks.
 In "-p" mode only file data is encrypted.
 At first, it seems files encrypted using "-hp" seem to offer more security
 since even the file headers are encrypted.
 However, in practice file encrypted using -"hp" can be attacked in two
 different way, 1) known partial plain-text attack 2) File header CRC verificati
on.
 File encrypted using "-p" are harder to brute-force, the decrypted (but
 still compressed) file data streams contain no information if they are
 valid compressed data stream.
 Hence to attack "-p" mode files, a full Un-RAR engine must be implemented
 which de-compresses the decrypted data, the computes the CRC over un-compressed
 data and compares the CRC with the value stored in the file header.
\end_layout

\begin_layout Standard
The "known partial plain-text attack" on "-hp" mode files was first found
 out Marc Bevland and used in his unrarhp tool.
 Our initiial implementation of RAR cracker could only deal with "-hp" mode
 files.
 It has been later extended by magnum (JtR jumbo's maintainer) to support
 "-p" mode files.
 magnum has even implemented GPU cracking support of RAR files!
\end_layout

\begin_layout Standard
[Insert RAR key stretching algorithm] [Insert RAR cracking snippet for "-hp"
 mode RAR files] [ Benchmark CPU, our GPU, igrargpu]
\end_layout

\begin_layout Section
LUKS 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Progress
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Linux Unified Key Setup or LUKS is a disk-encryption specification.
 The reference implementation for LUKS operates on Linux and is based on
 an enhanced version of cryptsetup, using dm-crypt as the disk encryption
 backend.
 Device-mapper crypt (dm-crypt) target provides transparent encryption of
 block devices using the kernel crypto API.
 LUKS is the standard for Linux hard disk encryption.
 By providing a standard on-disk-format, it does not only facilitate compatibili
ty among distributions, but also provides secure management of multiple
 user passwords.
 In contrast to existing solution, LUKS stores all setup necessary setup
 information in the partition header, enabling the user to transport or
 migrate his data seamlessly.
 While LUKS is a standard on-disk format, there is also a reference implementati
on.
 LUKS for dm-crypt is implemented in an enhanced version of cryptsetup.
 cryptsetup is used to conveniently setup dm-crypt managed block devices
 under Linux.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
LUKS header fields (size is 208 bytes + 48 * LUKS_NUMKEYS = 592 bytes)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="middle" width="2.5cm">
<column alignment="left" valignment="middle" width="2.5cm">
<column alignment="left" valignment="middle" width="6cm">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Magic
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0x9AA2D903, Magic
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Version
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0xB54BFB67, Magic
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cipher Name
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Determine what algorithms are used 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cipher Mode
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Version of the database format 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hash Spec
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Initial random number to start on the sha256 of the key 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Payload Offset
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Initialization vector used for all algorithms 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Key Bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted 128 random value using P’ with Twofish algorithm
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mkDigest 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SHA1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mkDigestSalt
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bytes 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SHA256 hash of only the contents (entire file minus starting 124 bytes)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
mkDigestIterations
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of iterations in PBKDF2 function
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UUID 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
40
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of rounds to do AES block encryption on the Master Key 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
keyblock structure (8 entries)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
48 bytes each
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
Where, keyblock structure has the following format,
\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
active
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
denotes whether this key slot is active or not
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
passwordIterations
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
parameters used for password processing
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
passwordSalt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
parameters used for password processing
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
keyMaterialOffset
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
parameters used for AF store/load
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
stripes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
parameters used for AF store/load
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our naive brute-force software (based on Revelation Python sources) is super
 slow and achieves a speed of merely 0.3 p/s.
 This slowness can be partially attributed to interpretive nature of Python
 code.
 Our second implementation in C (based on official cryptsetup sources) is
 three times faster and achieves roughly 1 p/s.
 [Give estimates for cracking 8 byte alpha and alphanumeric passwords].
 LUKS has upto 8 key slots.
 One clever attack is that we can choose to attack a key slot which has
 minimum cryptographic strength (i.e use lesser iterations in its key derivation
 function).
 Can I use LUKS or cryptsetup with a more secure (external) medium for key
 storage, e.g.
 TPM or a smartcard? Yes, see the answers on using a file-supplied key.
 You do have to write the glue-logic yourself though.
 Basically you can have cryptsetup read the key from STDIN and write it
 there with your own tool that in turn gets the key from the more secure
 key storage.
 
\end_layout

\begin_layout Section
Analysis of TrueCrypt 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Progress
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TrueCrypt 
\begin_inset CommandInset citation
LatexCommand citep
key "TCF:2004"

\end_inset

 is a popular on-the-fly encryption.
 It can create a file-hosted container or write a partition which consists
 of an encrypted volume with its own file system (contained within a regular
 file) which can then be mounted as if it were a real disk.
 TrueCrypt also supports device-hosted volumes, which can be created on
 either an individual partition or an entire disk.
 Because presence of a TrueCrypt volume can not be verified without the
 password, disk and filesystems utilities may report the filesystem as unformatt
ed or corrupted that may lead to data loss after incorrect user intervention
 or automatic "repair".
 
\end_layout

\begin_layout Standard
The standard volume header uses the first 512 bytes of the TrueCrypt container.
 It contains the master keys needed to decrypt the volume.
 The 512 bytes hidden volume header is stored 1536 bytes from the end of
 the host volume.
 TrueCrypt volumes have no "signature" or ID strings.
 Until decrypted, they appear to consist solely of random data.
 
\end_layout

\begin_layout Standard
Free space on each TrueCrypt volume is filled with random data when the
 volume is created.
\end_layout

\begin_layout Standard
It is not possible to identify TrueCrypt containers by simply looking for
 some well-defined magic string.
 This provides strong deniability.
 Information about the exact PKBDF2 function and cipher(s) used in an encrypted
 container is not stored in the header.
 As a consequence all possible combination must be tried.
 This slow down the brute force attack considerably.
 The various possible PBKDF2 algorithms used by TrueCrypt are : PBKDF2-HMAC-SHA2
56 with 2000 rounds etc.
 The various possible encrytion ciphers (including chained ciphers) are
 AES-XTS etc.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TrueCrypt Volume Format Specification (512 bytes)
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace{0.3cm}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="16" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="middle" width="2cm">
<column alignment="left" valignment="middle" width="1.5cm">
<column alignment="left" valignment="middle" width="2cm">
<column alignment="left" valignment="middle" width="6cm">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SALT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unencrypted
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Salt
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MAGIC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ASCII string "TRUE"
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Version
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Volume header format version
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Min.
 Version
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
crc_keys
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CRC32 of the key section
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vol_ctime
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Volume creation time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hdr_ctime
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Header creation time
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sz_hidvol
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size of hidden volume
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sz_vol
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size of volume
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
off_mk_scope
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Byte offset of the start of the master key scope
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sz_mk_scope
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Size of the encrypted area withint
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
he master key scope
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Flags
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Flag bits
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sec_sz
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sector size (in bytes)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unused
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
120 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reserved
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
crc_dhdr
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CRC32 of decrypted header (except keys)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
keys
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
256 bytes
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Concatenated primary and secondary master keys
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Benchmarks of all TC crackers out there (Excel bar chart).
 
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=Pseudo-code for cracking TrueCrypt volume]{r
esources/django_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Also mention real-life usage of these tools in competition ;)
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C,title=VNC cracking ]{resources/vnc_algorithm.c}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
.pfx / .p12 files 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Progress
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Work in progress.
\end_layout

\begin_layout Standard
JtR-jumbo is a community enhanced version of JtR with 
\end_layout

\begin_layout Standard
[Compiled debug version of OpenSSL to trace which encryption functions are
 called]
\end_layout

\begin_layout Standard
Compare our "trivial" cracker with Elcomsoft's EDPR (get benchmarks from
 all servers).
\end_layout

\begin_layout Standard
It defines a file format commonly used to store X.509 private keys with accompany
ing public key certificates, protected with a password-based symmetric key,
 and is the successor to PFX from Microsoft.
 PFX has received heavy criticism of being one of the most complex cryptographic
 protocols,[1] but nevertheless remains the only standard way today to store
 private keys and certificates in a single encrypted file.
\end_layout

\begin_layout Standard
Our .P12 cracker cheats by not not implementing its own crypto functions,
 instead it replies on OpenSSL's verifyxyz function to do the heavy lifting.
\end_layout

\begin_layout Standard
http://www.drh-consultancy.demon.co.uk/pkcs12faq.html/
\end_layout

\begin_layout Standard
#12 supports the following encryption algorithms.
\end_layout

\begin_layout Standard
128 bit RC4 with SHA1 40 bit RC4 with SHA1 3 key triple DES with SHA1 (168
 bits) 2 key triple DES with SHA1 (112 bits) 128 bit RC2 with SHA1 40 bit
 RC2 with SHA1
\end_layout

\begin_layout Standard
In addition the PKCS#5 v1.5 modes are possible as well.
 This also permits the following.
\end_layout

\begin_layout Standard
DES with MD5 (56bit) DES with MD2 (56bit)
\end_layout

\begin_layout Standard
What's this I hear about iteration counts? A.
 The algorithm used to generate keys from passwords and the MAC has an optional
 iteration count.
 This determines how many times part of the algorithm is repeated.
 It's a way of slowing down the key derivation process to make it harder
 to make dictionary attacks on the password.
 The -info option now prints information about iteration counts.
 Q.
 What iteration counts are used?
\end_layout

\begin_layout Standard
A.
 By default I set both iteration counts to 2048.
 If you use the -nomaciter option the MAC iteration count is also set to
 1 some software such as MSIE4 needs this option because it does not support
 mac iteration counts.
 If you use the noiter option the iteration count is set to 1: since this
 makes dictionary attacks on the password easier this is not recommended.
\end_layout

\begin_layout Standard
MSIE5 uses 2000 for the encryption iteration count.
 If you have the 'enable strong protection' option checked then it uses
 2000 for the MAC count otherwise it uses 1 (for compatability with earlier
 versions of MSIE).
\end_layout

\begin_layout Standard
ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/pkcs-12v1.pdf
\end_layout

\begin_layout Standard
Both are PKCS #12 files (Personal Information Exchange Syntax)
\end_layout

\begin_layout Section
Mozilla master passwords 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Progress
\end_layout

\end_inset


\end_layout

\begin_layout Standard
implements the only multi-core open-source RACF hash cracking software.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=Python,caption=RACF hashing algorithm]{resources/racf_a
lgorithm.py}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Research into the RACF system was done in collaboration with Nigel Pentland
 (author of CRACF) and Phil Young.
 
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=RACF cracker benchmarks]{resources/racf_outp
ut.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Analysis of encrypted 7-Zip files 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Progress
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Work in progress.
\end_layout

\begin_layout Chapter
Analysis of security of various authentication protocols 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Progress
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "chap:auth-protocols"

\end_inset


\end_layout

\begin_layout Section
Kerberos v5 authentication protocol 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Progress
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Kerberos is a computer network authentication protocol which works on the
 basis of "tickets" to allow nodes communicating over a non-secure network
 to prove their identity to one another in a secure manner .
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=25pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C,caption=LastPass Cracker]{resources/lastpass_algorith
m.c}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Essentially we decrypt the encrypted_username value and compare it against
 the original username to verify if the gived password was correct or not.
 For details see src/lastpass_fmt_plug.c in JtR source tree.
 
\end_layout

\begin_layout Standard
We compare the performance of LastPass cracker on different machines below,
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
LastPass Cracking Benchmarks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/Agile Keychain Benchmarks.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Benchmarks} 
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,breaklines=true,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=LastPass cracking benchmarks]{resources/kwal
let_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Describe Ettercap + JtR work
\end_layout

\begin_layout Section
MongoDB authentication protocol 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Progress
\end_layout

\end_inset


\end_layout

\begin_layout Standard
DONE.
 At least it has some protection unlike Redis which sends the password in
 clear text
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=25pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C,caption=LastPass Cracker]{resources/lastpass_algorith
m.c}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Essentially we decrypt the encrypted_username value and compare it against
 the original username to verify if the gived password was correct or not.
 For details see src/lastpass_fmt_plug.c in JtR source tree.
 
\end_layout

\begin_layout Standard
We compare the performance of LastPass cracker on different machines below,
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
LastPass Cracking Benchmarks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/Agile Keychain Benchmarks.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Benchmarks} 
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,breaklines=true,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=LastPass cracking benchmarks]{resources/kwal
let_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Describe Ettercap + JtR work
\end_layout

\begin_layout Section
MySQL challenge-response authentication protocol 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Progress
\end_layout

\end_inset


\end_layout

\begin_layout Standard
DONE.
 Describe Ettercap + JtR work
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=25pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C,caption=LastPass Cracker]{resources/lastpass_algorith
m.c}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Essentially we decrypt the encrypted_username value and compare it against
 the original username to verify if the gived password was correct or not.
 For details see src/lastpass_fmt_plug.c in JtR source tree.
 
\end_layout

\begin_layout Standard
We compare the performance of LastPass cracker on different machines below,
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
LastPass Cracking Benchmarks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/Agile Keychain Benchmarks.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Benchmarks} 
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,breaklines=true,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=LastPass cracking benchmarks]{resources/kwal
let_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Describe Ettercap + JtR work
\end_layout

\begin_layout Section
PostgreSQL authentication protocol 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Progress
\end_layout

\end_inset


\end_layout

\begin_layout Standard
DONE.
 Describe Ettercap + JtR + Nmap + Metasploit work.
 Man in the middle downgrade attack.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=25pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C,caption=LastPass Cracker]{resources/lastpass_algorith
m.c}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Essentially we decrypt the encrypted_username value and compare it against
 the original username to verify if the gived password was correct or not.
 For details see src/lastpass_fmt_plug.c in JtR source tree.
 
\end_layout

\begin_layout Standard
We compare the performance of LastPass cracker on different machines below,
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
LastPass Cracking Benchmarks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/Agile Keychain Benchmarks.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Benchmarks} 
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,breaklines=true,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=LastPass cracking benchmarks]{resources/kwal
let_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Describe Ettercap + JtR work
\end_layout

\begin_layout Section
Oracle O5LOGON protocol 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Progress
\end_layout

\end_inset


\end_layout

\begin_layout Standard
DONE.
 Describe Ettercap + JtR + Nmap work
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=25pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C,caption=LastPass Cracker]{resources/lastpass_algorith
m.c}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Essentially we decrypt the encrypted_username value and compare it against
 the original username to verify if the gived password was correct or not.
 For details see src/lastpass_fmt_plug.c in JtR source tree.
 
\end_layout

\begin_layout Standard
We compare the performance of LastPass cracker on different machines below,
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
LastPass Cracking Benchmarks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/Agile Keychain Benchmarks.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Benchmarks} 
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,breaklines=true,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=LastPass cracking benchmarks]{resources/kwal
let_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Describe Ettercap + JtR work
\end_layout

\begin_layout Section
iSCSI CHAP authentication protocol 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Progress
\end_layout

\end_inset


\end_layout

\begin_layout Standard
iSCSI (Internet Small Computer System Interface) is an Internet Protocol
 (IP) based networking standard for linking storage facilities.
 iSCSI allows clients (called initiators) to send SCSI commands (CDBs) to
 SCSI storage devices (targets) on remote servers to facililate data transfer.
 It is a storage area network (SAN) protocol, allowing organizations to
 consolidate storage into data center storage arrays while providing hosts
 (such as database and web servers) with the illusion of locally attached
 disks.
\end_layout

\begin_layout Standard
iSCSI targets can be password protected by using CHAP protocol.
 <Decribe algorithm>.We have extended Ettercap to sniff and decode the key
 packets involved in iSCSI CHAP authentication protocol.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
iSCSI initiator to target packet
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/iSCSI-1.png
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
iSCSI target to initiator packet
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/iSCSI-2.png
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We have written a custom cracker for sniffed iSCSI CHAP authentication hashes
 and the following snippet shows the main steps involved,
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=25pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C,caption=iSCSI Cracker]{resources/lastpass_algorithm.c}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Essentially we decrypt the encrypted_username value and compare it against
 the original username to verify if the gived password was correct or not.
 For details see src/lastpass_fmt_plug.c in JtR source tree.
 
\end_layout

\begin_layout Standard
We compare the performance of LastPass cracker on different machines below,
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
iSCSI Cracking Benchmarks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/Agile Keychain Benchmarks.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Benchmarks} 
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,breaklines=true,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=iSCSI cracking benchmarks]{resources/kwallet
_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Describe Ettercap + JtR work
\end_layout

\begin_layout Section
VNC protocol 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In Progress
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Virtual Network Computing (VNC) is a graphical desktop sharing system that
 uses the RFB protocol (remote framebuffer) to remotely control another
 computer.
 It transmits the keyboard and mouse events from one computer to another,
 relaying the graphical screen updates back in the other direction, over
 a network.
 VNC is platform-independent – a VNC viewer on one operating system may
 connect to a VNC server on the same or any other operating system.
 A VNC system consists of a client, a server, and a communication protocol.
 The VNC server is the program on the machine that shares its screen.
 The server passively allows the client to take control of it.
 The VNC client (or viewer) is the program that watches, controls, and interacts
 with the server.
 The client controls the server.
 The VNC protocol (RFB) is very simple, based on one graphic primitive from
 server to client ("Put a rectangle of pixel data at the specified X,Y position"
) and event messages from client to server.
 VNC by default uses TCP port 5900+N,[5][6] where N is the display number.
 The first step in attacking VNC cracking involves passive sniffing of the
 VNC traffic.
 Once the traffic has been captured.
\end_layout

\begin_layout Standard
VNC encryption key can be potentially broken only by mere passive sniffing
 of the traffic.
 In our opinion, VNC authentication protocol offers poor security and hasn't
 been fixed even in the newer versions of the RFB protocol.
\end_layout

\begin_layout Standard
[Paste wireshark screenshots] 
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=25pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C,caption=LastPass Cracker]{resources/lastpass_algorith
m.c}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Essentially we decrypt the encrypted_username value and compare it against
 the original username to verify if the gived password was correct or not.
 For details see src/lastpass_fmt_plug.c in JtR source tree.
 
\end_layout

\begin_layout Standard
We compare the performance of LastPass cracker on different machines below,
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
LastPass Cracking Benchmarks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/Agile Keychain Benchmarks.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Benchmarks} 
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,breaklines=true,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=LastPass cracking benchmarks]{resources/kwal
let_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Describe Ettercap + JtR work
\end_layout

\begin_layout Section
LastPass authentication protocol 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Improve Me
\end_layout

\end_inset


\end_layout

\begin_layout Standard
LastPass is a free online password manager and Form Filler that makes your
 web browsing easier and more secure.
 User's sensitive data is encrypted locally before upload so even LastPass
 cannot get access to it 
\begin_inset CommandInset citation
LatexCommand cite
key "LastPass"

\end_inset

.
 LastPass Password Manager protects passwords by using local AES encryption
 and a master password.
\end_layout

\begin_layout Standard
LastPass Password Manager is a closed source software and uses a proprietary
 file format.
 Earlier versions of LastPass used a weak KDF function and were susceptible
 to brute foce at high speeds (see 
\begin_inset CommandInset citation
LatexCommand cite
key "LastPass + Belenko"

\end_inset

).
 However 
\begin_inset CommandInset citation
LatexCommand cite
key "LastPass + Belenko"

\end_inset

 is secretive (being from a commercial password cracking company) and does
 not contain any internal details.
 The lastest verions of LastPass Password Manager employ PBKDF2-SHA256 with
 variable number of iterations to slow down brute-force attacks.
 
\end_layout

\begin_layout Standard
In this work, we present security analysis of the lastest version of LastPass
 Password Manager.
 LastPass denied our requests to open up their proprietary file format for
 third-party security analysis.
 So, instead of analyzing the LastPass file format and finding possible
 offline attacks against it, we shifted to studying the authentication protocol
 used by LastPass.
\end_layout

\begin_layout Standard
The following screenshot shows the traffic exchanged between the LastPass
 Password Manager plug-in (running in the browser) and LastPass backend
 servers,
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
LastPass authentication protocol
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/LastPass_sniff.png
	scale 35

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
After some analsysis, we found out that the query parameter 
\begin_inset Quotes eld
\end_inset

encrypted_username
\begin_inset Quotes erd
\end_inset

 is essentially username (known value) encrypted with a key derived from
 user password.
 LastPass uses a PBKDF2 as its key derivation function.
 We have written a custom cracker for sniffed LastPass authentication traffic
 and the following snippet shows the main steps involved,
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=25pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=C,caption=LastPass Cracker]{resources/lastpass_algorith
m.c}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Essentially we decrypt the encrypted_username value and compare it against
 the original username to verify if the gived password was correct or not.
 For details see src/lastpass_fmt_plug.c in JtR source tree.
 
\end_layout

\begin_layout Standard
We compare the performance of LastPass cracker on different machines below,
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
LastPass Cracking Benchmarks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/Agile Keychain Benchmarks.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Benchmarks} 
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,breaklines=true,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=LastPass cracking benchmarks]{resources/kwal
let_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Offline attacks on LastPass offline database are work in progress.
\end_layout

\begin_layout Section
Clipperz authentication protocol 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Improve Me
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Clipperz is a popular free online password manager 
\begin_inset CommandInset citation
LatexCommand cite
key "Clipperz"

\end_inset

.
 It does encryption on the local browser which gurantees confidentiality
 of data.
 Clipperz supports exporting encrypted databases into offline versions.
 Offline versions use the same cryptographic technology as used by the online
 version.
\end_layout

\begin_layout Standard
Clipperz does not believe in 
\begin_inset Quotes eld
\end_inset

security through obscurity
\begin_inset Quotes erd
\end_inset

 (unlike LastPass) and all the code behing Clipperz is open-source 
\begin_inset CommandInset citation
LatexCommand cite
key "Clipperz github"

\end_inset

.
 Clipperz uses SRP (Secure Remote Password protocol, see 
\begin_inset CommandInset citation
LatexCommand cite
key "SRP 1"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand cite
key "SRP 2"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand cite
key "SRP algorithm"

\end_inset

) for online and offline authentication.
 SRP is essentailly an authentication protocol for password-based, mutual
 authentication over an insecure network connection and requires both sides
 of the connection to have knowledge of the user’s password.
 SRP offers security and deployment advantages over other challenge-response
 protocols, such as Kerberos and SSL, in that it does not require trusted
 key servers or certificate infrastructures.
 Instead, small verification keys derived from each user’s password are
 stored and used by each SRP server application 
\begin_inset CommandInset citation
LatexCommand cite
key "SRP algorithm"

\end_inset

.
 
\begin_inset Quotes eld
\end_inset

SRP does not store plaintext passwords on the server side but instead uses
 what is known as a “non plaintext-equivalent verifier” 
\begin_inset CommandInset citation
LatexCommand cite
key "Clipperz Details"

\end_inset

.
\end_layout

\begin_layout Standard
Password verifier is derived from a Private key (called x) by using the
 formula v = g^x, where x (Private key) = H(s, H( I | ‘:’ | p )), g is generator
 modulo N, I is username, p is cleartext password, H() is one-way hash function
 and s is salt.
 In theory, 
\begin_inset Quotes eld
\end_inset

compromized verification keys (called v) are of little value to an attacker
\begin_inset Quotes erd
\end_inset

.
 However in practice, it is possible to brute-force the original password
 from the verification key at high speeds.
\end_layout

\begin_layout Standard
Ideally, for increassed resistance against brute-force attacks, a costly
 (slow) one-way hash function (H) like PBKDF2 should be used.
 However, in reality we have seen very fast hash functions (like single
 iterations of SHA1 or SHA256) being used (See
\begin_inset CommandInset citation
LatexCommand cite
key "Clipperz"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand cite
key "Blizzard SRP"

\end_inset

).
 This allows an attacker to mount brute-force attack at high-speeds.
\end_layout

\begin_layout Standard
The following snippet show how the salt and the verifier (verification key)
 are stored in the database,
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=none,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=Clipperz secret data]{resources/clipperz_met
adata.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following snippet shows how we can derive a verifer from a given salt
 and user password and check if the gives user password was correct,
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=none,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=Python,title=Clipperz Cracker]{resources/clipperz_algor
ithm.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
For details see src/clipperz_fmt_plug.c in JtR source tree.
 We compare the performance of Clipperz cracker on different machines below,
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Clipperz Cracking Benchmarks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/Agile Keychain Benchmarks.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Benchmarks} 
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,breaklines=true,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=Clipperz cracking benchmarks]{resources/kwal
let_output.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frontmatter
\end_layout

\begin_layout Plain Layout


\backslash
maketitle
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Analysis of security of various backup solution.
 
\begin_inset CommandInset label
LatexCommand label
name "chap:backup-solutions"

\end_inset


\end_layout

\begin_layout Section
Analysis of Dropbox
\end_layout

\begin_layout Section
Analysis of inSync Druva
\end_layout

\begin_layout Standard
Druva inSync is an on-premise and cloud-based backup software.
 Druva provides enterprise laptop backup solutions that protect corporate
 users data with 10x faster backups and 90% reduction in storage requirements.
 The data encrypted both during transit (256-bit SSL) and in the storage
 (256-bit AES) 1,576 enterprises.
 
\end_layout

\begin_layout Subsubsection
1,126,840 endpoints, 46 countries, 98% Customer Satisfaction Rate, Customers
 include NASA, PwC, Deloitte, Amway and McAfee among others
\end_layout

\begin_layout Standard
Rated “excellent” by Gartner.
 inSync Cloud offers the industry-best security.
\end_layout

\begin_layout Standard
SAS 70 Type II, PCI DSS Level 1, ISO 27001, ISAE 3000 Type I
\end_layout

\begin_layout Standard
Industry-First Two-Factor Encryption.
 Even Druva can’t access your data.
\end_layout

\begin_layout Standard
How do they de-deduplication? Does “dropship” like attack works?
\end_layout

\begin_layout Standard
“inSync Cloud offers the industry-best security”
\end_layout

\begin_layout Subsection
Authetication Issues
\end_layout

\begin_layout Standard
Uses single iteration of md5 to protect admin and user passwords.
 hash = md5(id + password)
\end_layout

\begin_layout Standard
select id, name, emailid, password from administrator
\end_layout

\begin_layout Standard
Such hashes are crackable at high speeds using JtR or hashcat family of
 softwares.
 (4.2B c/s possible with oclHashcat-lite on AMD 7970)
\end_layout

\begin_layout Standard
Fix: use PBKDF2
\end_layout

\begin_layout Standard
“inSync Cloud offers the industry-best security”
\end_layout

\begin_layout Standard
We use single iteration of md5 to protect admin and user passwords!
\end_layout

\begin_layout Standard
Such hashes are crackable at high speeds using JtR or hashcat family of
 softwares.
\end_layout

\begin_layout Standard
LinkedIn leak (6.5 million SHA1 hashes, over 90% of them got cracked!)
\end_layout

\begin_layout Standard
@druvainc: Ever heard about PBKDF2?
\end_layout

\begin_layout Standard
Best not to invent your own crazy schemes
\end_layout

\begin_layout Subsection
Licensing Issues
\end_layout

\begin_layout Standard
Trial license expires after 30 days.
 Enterprise license is limited to 500 users per server.
 Need to pay extra $$$ for features like file sharing, DLP and analytics
 and these are “time-bombed”.
\end_layout

\begin_layout Standard
def encrypt(in): return base64.b64encode(bz2.compress(in, 9)).
 It is easy to reverse-engineer and generate unlimited Enterprise licenses.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Clipperz Cracking Benchmarks
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename resources/Enterprise Forever License.png
	scale 75

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Licensing Issues
\end_layout

\begin_layout Standard
Hard problem to solve.
 
\end_layout

\begin_layout Standard
Even the industry “best” protection systems have been cracked (eventually)!
\end_layout

\begin_layout Standard
Asymmetric cryptography can help.
 Use it
\end_layout

\begin_layout Subsubsection
Stealing STMP configuration
\end_layout

\begin_layout Standard
It is mandatory to configure SMTP
\end_layout

\begin_layout Standard
Following “encryption” function is used to “encrypt” SMTP password.
\end_layout

\begin_layout Standard
Possible to do insidious social-engineering attacks if access to this SMTP
 account is gained.
\end_layout

\begin_layout Standard
def encrypt(in): return base64.b64encode(bz2.compress(in, 9)) Maybe try using
 CryptoAPI for slightly better protection
\end_layout

\begin_layout Subsubsection
 Arbitrary remote code execution vulnerability
\end_layout

\begin_layout Standard
License files are in fact pickled strings.
\end_layout

\begin_layout Standard
We can generate malicious license files! (share blackhat reference)
\end_layout

\begin_layout Standard
A successful social engineering attack on inSync administrator can lead
 to complete data loss! pickle code execution
\end_layout

\begin_layout Standard
import pickle pickle.loads("cos
\backslash
nsystem
\backslash
n(S'ls ~'
\backslash
ntR.")
\end_layout

\begin_layout Standard
This code runs ls command
\end_layout

\begin_layout Standard
Source: Nadia Alramli's Blog
\end_layout

\begin_layout Standard
Google for “Sour Pickles Black Hat” for more information.
 Never do “pickle.load(file_handle)” when data source is not trusted and
 controlled.
\end_layout

\begin_layout Standard
By design, pickle allows code execution.
 It sure is convenient but isn't secure.
\end_layout

\begin_layout Standard
Writing your own custom plain-text format is almost trivial.
 Stop misusing pickle.
 
\end_layout

\begin_layout Subsubsection
 on-the-wire data protection claims
\end_layout

\begin_layout Standard
“inSync Cloud offers the industry-best security”
\end_layout

\begin_layout Standard
“256-bit SSL encryption for data in transit”
\end_layout

\begin_layout Standard
Secure HTTPS and LDAPS protocols for access”
\end_layout

\begin_layout Standard
Reality.
\end_layout

\begin_layout Standard
256-bit SSL? Sure
\end_layout

\begin_layout Standard
SSL certificate verification? No #epicfail
\end_layout

\begin_layout Standard
inSync client (installed on end devices) does NO verification of SSL certificate
s whatsoever.
\end_layout

\begin_layout Standard
Hello MiTM attacks!
\end_layout

\begin_layout Standard
https://github.com/kholia/ettercap/tree/inSync
\end_layout

\begin_layout Standard
Allows to steal passwords or “hashes”
\end_layout

\begin_layout Standard
Both can be used to steal all data!
\end_layout

\begin_layout Standard
MiTM Prevention
\end_layout

\begin_layout Standard
FWIW decade old RC4 128-bit is still good enough.
 256-bit is almost pure marketing
\end_layout

\begin_layout Standard
256-bit doesn’t do any good if you are not doing SSL certificate validation
\end_layout

\begin_layout Standard
Deploy “real” certificates on inSync server for best results
\end_layout

\begin_layout Standard
Publish (and verify) certificate fingerprint
\end_layout

\begin_layout Subsubsection
 on-the-wire data protection claims
\end_layout

\begin_layout Standard
Druva uses py2exe (on Windows) to bundle and distribute inSync
\end_layout

\begin_layout Standard
It is easy to reverse-engineer Druva inSync.
\end_layout

\begin_layout Standard
7-zip + a Python decompiler are enough to obtain source-code of inSync
\end_layout

\begin_layout Standard
Bytecode Protection Techniques
\end_layout

\begin_layout Standard
opcode obfuscation, 
\end_layout

\begin_layout Subsubsection
Vendor Response
\end_layout

\begin_layout Standard
Compression is not “encryption”.
\end_layout

\begin_layout Standard
Contacted vendor on 18th December 2012.
 They asked for “details” which I sent promptly.
 No further contact.
\end_layout

\begin_layout Standard
Contacted CEO and CTO on 2nd January 2013.
 Haven’t heard back so far.
\end_layout

\begin_layout Standard
“Companies don't see it as a security problem; they see it as a PR problem”
 - Bruce Schneier on security issues.
\end_layout

\begin_layout Subsubsection
Lessons
\end_layout

\begin_layout Standard
LinkedIn leak (6.5 million SHA1 hashes, over 90% of them got cracked!)
\end_layout

\begin_layout Standard
@druvainc: Ever heard about PBKDF2?
\end_layout

\begin_layout Standard
Best not to invent your own crazy scheme
\end_layout

\begin_layout Chapter
Analysis of security of various data encryption softwares
\begin_inset CommandInset label
LatexCommand label
name "chap:data-encryption"

\end_inset


\end_layout

\begin_layout Standard
PGP WDE, LUKS, TrueCrypt
\end_layout

\begin_layout Chapter
Analysis of security of various password hashing algorithms.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "chap:hashes-JtR"

\end_inset


\end_layout

\begin_layout Section
RACF cracker 
\end_layout

\begin_layout Standard
RACF (Resource Access Control Facility) is IBM security system that provides
 access control and auditing functionality for the z/OS and z/VM operating
 systems.
 This work is the only published source of complete RACF algorithm and RACF
 database parser.
 In addition, this work implements the only multi-core open-source RACF
 hash cracking software.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=Python,caption=RACF hashing algorithm]{resources/racf_a
lgorithm.py}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Research into the RACF system was done in collaboration with Nigel Pentland
 (author of CRACF) and Phil Young.
 
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=RACF cracker benchmarks]{resources/racf_outp
ut.txt}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Django 1.4 password hashing algorithm
\end_layout

\begin_layout Standard
Earlier versions (< 1.4) of Django didn't use key-stretched hashing algorithms,
 instead they used single rounds of either SHA1, MD5 or DES crypt algorithms.
 Hence older Django hashes were vulnerable to brute-forcing at high speeds.
 Django 1.4 introduces a new flexible password storage system and uses PBKDF2
 with SHA256 hash, a password stretching mechanism.
 By default 10, 000 iterations are used for key stretching.
\end_layout

\begin_layout Standard
\begin_inset Box Shadowbox
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100text%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
lstlistingname}{Code}
\end_layout

\begin_layout Plain Layout


\backslash
lstset{tabsize=2,breaklines=true,numbers=left,basicstyle=
\backslash
footnotesize
\backslash
ttfamily,xleftmargin=30pt}
\end_layout

\begin_layout Plain Layout


\backslash
lstinputlisting[language=bash,title=Django Benchmarks]{resources/django_output.tx
t}
\end_layout

\begin_layout Plain Layout


\backslash
vspace{0.2cm}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Our single-core implementation of Django 1.4 achieves only 46 c/s on AMD
 FX-8120 CPU while the multi-core version achieves 203 c/s for a speedup
 of 4.7x.
 Overall cracking speed and mutli-core speedup factor can further be improved
 by using a custom implementation of PBKDF2-HMAC-SHA-256 algorithm instead
 of using high-level OpenSSL interfaces.
 One side-effect of using CPU intensive password hashing algorithms on servers
 (e.g.
 bcrypt, ph-pass, scrypt) is that it becomes trivial to mount a DoS (denial
 of service) attack on them.
 Since Django run on Python (which effectively uses a single CPU core for
 running Python code, due to GIL), such DoS attacks become even more trivial
 to mount against servers running Django.To avoid such attacks DoS attacks,
 care must be taken to implement policies which deny connection attempts
 after an IP has failed login process X number of times.
 This can be done using softwares like fail2ban.
 etc etc.
 (benchmark Django implementation and estimate the number of connections
 needed to DoS the site).
 Online attacks is to limit both per-IP attempts per second, and per-username
 attempts per second, with the limit being tripped causing an "automatic
 reject."
\end_layout

\begin_layout Chapter
Related work (work not described in this paper)
\end_layout

\begin_layout Standard
Some other JtR plug-in that were written (but not described in this paper)
 are RAdmin, SybaseASE, GOST, SIP, IKE PSK, Nuked Clan, MSSQL 12, wbb3,
 vms, WebEdition CMS
\end_layout

\begin_layout Chapter
Future Work
\end_layout

\begin_layout Standard
Implement DES on GPU, this will benefit RAC format.
 Implement AES on GPU for KeePass format.
 GPU implementation of PBKDF-HMAC-WHIRLPOOL etc.
\end_layout

\begin_layout Itemize

\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
This file is setup to use a bibtex file sample.bib and uses the
\end_layout

\begin_layout Plain Layout
plain style.
  Other styles may be used depending on the conventions of your field of
 study.
 Note: the bibliography must come before the appendices.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "sample"
options "plainnat"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Use this to reset the appendix counter.
  Note that the FoGS requires that the word ``Appendices'' appear in the
 table of contents either before each appendix lable or as a division denoting
 the start of the appendices.
  We take the latter option
\end_layout

\begin_layout Plain Layout
here.
  This is ensured by making the 
\backslash
texttt{appendicestoc} option
\end_layout

\begin_layout Plain Layout
 a default option to the UBC thesis class.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\start_of_appendix
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%dummy comment inserted by tex2lyx to ensure that this paragraph is not
 empty
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Chapter
First Appendix
\end_layout

\begin_layout Standard
Here you can have your appendices.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% Indices come here.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\end_body
\end_document
